<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MSSOG ENGINE v6.0 ULTRA - Quantum 3D Suite</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/FXAAShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/DecalGeometry.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/curves/NURBSCurve.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/modifiers/TessellationModifier.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;700&display=swap');
        body {
            font-family: 'JetBrains+Mono', monospace;
            background-color: #000;
            color: #ccc;
            overflow: hidden;
            user-select: none;
        }
        .ui-glass {
            background: rgba(10, 10, 10, 0.95);
            backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 77, 0, 0.1);
        }
        .sidebar { width: 340px; height: 100vh; z-index: 50; transition: width 0.3s; }
        .active-tool { background: #ff4d00 !important; color: white !important; box-shadow: 0 0 20px rgba(255, 77, 0, 0.3); }
        .input-dark {
            background: #0d0d0d;
            border: 1px solid #222;
            font-size: 10px;
            padding: 8px;
            border-radius: 6px;
            outline: none;
            color: #eee;
            width: 100%;
        }
        .input-dark:focus { border-color: #ff4d00; }
        .tree-item { 
            padding: 8px 12px; 
            font-size: 10px; 
            cursor: pointer; 
            display: flex; 
            align-items: center; 
            gap: 8px; 
            border-bottom: 1px solid rgba(255,255,255,0.02);
        }
        .tree-item:hover { background: rgba(255, 77, 0, 0.05); }
        .tree-item.selected { background: rgba(255, 77, 0, 0.15); border-left: 3px solid #ff4d00; }
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: #ff4d00; }
        .kpi-label { font-size: 8px; color: #555; font-weight: bold; text-transform: uppercase; letter-spacing: 1px; }
        .kpi-value { font-size: 11px; color: #aaa; font-weight: bold; }
        #viewport { width: 100%; height: 100vh; }
        .btn-icon { padding: 6px; border-radius: 4px; border: 1px solid #222; background: #0a0a0a; transition: all 0.2s; }
        .btn-icon:hover { border-color: #ff4d00; color: #ff4d00; }
        .badge { font-size: 7px; background: #ff4d00; color: white; padding: 1px 4px; border-radius: 3px; }
        .tab { padding: 4px 10px; border-radius: 6px; font-size: 9px; background: #0a0a0a; }
        .tab.active { background: #ff4d00; color: white; }
        .inspector-section { border-bottom: 1px solid rgba(255,77,0,0.1); padding-bottom: 12px; margin-bottom: 12px; }
        .grid-row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    </style>
</head>
<body class="flex">

    <!-- SPLASH/LOGIN -->
    <div id="login-screen" class="fixed inset-0 z-[200] flex items-center justify-center bg-black">
        <div class="ui-glass p-16 rounded-[50px] text-center border-orange-500/30 max-w-lg w-full mx-4 shadow-[0_0_100px_rgba(255,77,0,0.1)]">
            <div class="mb-8 text-7xl animate-pulse">üõ∞Ô∏è</div>
            <h1 class="text-6xl font-black mb-4 tracking-tighter italic"><span class="text-orange-500">MS</span>SOG</h1>
            <p class="text-zinc-600 text-[10px] mb-12 uppercase tracking-[0.5em]">Quantum Asset Intelligence Engine v6.0</p>
            <input type="password" id="password" placeholder="SECURITY KEY" class="input-dark text-center tracking-[1em] mb-6 p-5 text-lg">
            <button onclick="checkAccess()" class="w-full py-5 rounded-2xl bg-orange-600 hover:bg-orange-500 text-white font-bold transition-all shadow-lg shadow-orange-900/40">INITIALIZE CORE</button>
        </div>
    </div>

    <!-- MAIN UI -->
    <div id="editor-ui" class="hidden flex w-full h-full">
        
        <!-- LEFT: HIERARCHY & ASSETS -->
        <aside class="sidebar ui-glass border-r border-zinc-900 flex flex-col">
            <div class="p-4 border-b border-zinc-900 flex flex-col gap-3">
                <div class="flex justify-between items-center">
                    <h2 class="text-[10px] font-bold text-orange-500 uppercase tracking-[0.2em]">Scene Tree</h2>
                    <div class="flex gap-2">
                        <button onclick="addFolder()" class="btn-icon" title="New Folder">üìÅ</button>
                        <button onclick="exportScene()" class="btn-icon" title="Save Project">üíæ</button>
                        <button onclick="clearScene()" class="btn-icon" title="Reset Scene">üßπ</button>
                    </div>
                </div>
                <input type="text" id="tree-search" placeholder="Search objects..." class="input-dark" oninput="updateSceneTree()">
            </div>

            <div id="scene-tree" class="flex-1 overflow-y-auto"></div>

            <div class="p-4 border-t border-zinc-900 space-y-3">
                <p class="kpi-label">Construct</p>
                <div class="grid grid-cols-3 gap-1">
                    <button onclick="addPrimitive('cube')" class="py-2 bg-zinc-900 text-[9px] rounded hover:border-orange-500 border border-zinc-800">CUBE</button>
                    <button onclick="addPrimitive('sphere')" class="py-2 bg-zinc-900 text-[9px] rounded hover:border-orange-500 border border-zinc-800">SPHERE</button>
                    <button onclick="addPrimitive('plane')" class="py-2 bg-zinc-900 text-[9px] rounded hover:border-orange-500 border border-zinc-800">PLANE</button>
                </div>
                <div class="grid grid-cols-3 gap-1 mt-2">
                    <button onclick="addPrimitive('torus')" class="py-2 bg-zinc-900 text-[9px] rounded hover:border-orange-500 border border-zinc-800">TORUS</button>
                    <button onclick="addPrimitive('cylinder')" class="py-2 bg-zinc-900 text-[9px] rounded hover:border-orange-500 border border-zinc-800">CYL</button>
                    <button onclick="addPrimitive('cone')" class="py-2 bg-zinc-900 text-[9px] rounded hover:border-orange-500 border border-zinc-800">CONE</button>
                </div>
                <button onclick="document.getElementById('glb-input').click()" class="w-full py-3 bg-orange-600/10 text-orange-500 border border-orange-500/30 text-[9px] font-bold rounded-lg hover:bg-orange-600/20">UPLOAD GLB/GLTF</button>
                <input type="file" id="glb-input" class="hidden" accept=".glb,.gltf" onchange="handleGlbUpload()">
                
                <!-- 30 FITUR TAMBAHAN: BUTTONS -->
                <div class="pt-4 border-t border-zinc-800">
                    <p class="kpi-label mb-2">Quick Actions</p>
                    <div class="grid grid-cols-2 gap-1">
                        <button onclick="centerAllObjects()" class="py-2 bg-zinc-900/50 text-[8px] rounded hover:border-blue-500 border border-zinc-800">CENTER ALL</button>
                        <button onclick="randomizePositions()" class="py-2 bg-zinc-900/50 text-[8px] rounded hover:border-purple-500 border border-zinc-800">RANDOMIZE</button>
                        <button onclick="alignToGrid()" class="py-2 bg-zinc-900/50 text-[8px] rounded hover:border-green-500 border border-zinc-800">ALIGN GRID</button>
                        <button onclick="toggleWireframeAll()" class="py-2 bg-zinc-900/50 text-[8px] rounded hover:border-yellow-500 border border-zinc-800">WIRE ALL</button>
                        <button onclick="createLightProbe()" class="py-2 bg-zinc-900/50 text-[8px] rounded hover:border-cyan-500 border border-zinc-800">LIGHT PROBE</button>
                        <button onclick="bakeSceneLighting()" class="py-2 bg-zinc-900/50 text-[8px] rounded hover:border-pink-500 border border-zinc-800">BAKE LIGHT</button>
                        <button onclick="generateTerrain()" class="py-2 bg-zinc-900/50 text-[8px] rounded hover:border-emerald-500 border border-zinc-800">TERRAIN</button>
                        <button onclick="createParticles()" class="py-2 bg-zinc-900/50 text-[8px] rounded hover:border-rose-500 border border-zinc-800">PARTICLES</button>
                    </div>
                </div>
            </div>
        </aside>

        <!-- CENTER: VIEWPORT -->
        <main class="flex-1 relative flex flex-col">
            <!-- TOOLBAR -->
            <div class="absolute top-6 left-1/2 -translate-x-1/2 z-[60] flex items-center gap-1 ui-glass p-2 rounded-2xl shadow-2xl border-zinc-800">
                <div class="flex gap-1 px-2 border-r border-zinc-800">
                    <button id="tool-translate" onclick="setToolMode('translate')" class="px-4 py-2 rounded-xl text-[10px] active-tool">G</button>
                    <button id="tool-rotate" onclick="setToolMode('rotate')" class="px-4 py-2 rounded-xl text-[10px] hover:bg-zinc-900">R</button>
                    <button id="tool-scale" onclick="setToolMode('scale')" class="px-4 py-2 rounded-xl text-[10px] hover:bg-zinc-900">S</button>
                </div>
                <div class="flex gap-1 px-2">
                    <button id="snap-btn" onclick="toggleSnap()" class="px-3 py-2 rounded-xl text-[9px] hover:bg-zinc-900">SNAP: OFF</button>
                    <button onclick="undo()" class="p-2 hover:text-orange-400">‚Ü©</button>
                    <button onclick="redo()" class="p-2 hover:text-orange-400">‚Ü™</button>
                    <button onclick="duplicateObject()" class="px-3 py-2 rounded-xl text-[9px] hover:bg-zinc-900">CLONE</button>
                </div>
                <div class="flex gap-1 px-2 border-l border-zinc-800">
                    <button onclick="toggleSymmetry()" class="px-3 py-2 rounded-xl text-[9px] hover:bg-zinc-900">SYM: OFF</button>
                    <button onclick="togglePhysics()" class="px-3 py-2 rounded-xl text-[9px] hover:bg-zinc-900">PHYSICS</button>
                    <button onclick="toggleXR()" class="px-3 py-2 rounded-xl text-[9px] hover:bg-zinc-900">XR MODE</button>
                </div>
            </div>

            <div id="viewport"></div>

            <!-- FOOTER KPI -->
            <div class="absolute bottom-6 left-6 z-50 pointer-events-none flex gap-8">
                <div><p class="kpi-label">Performance</p><p class="kpi-value" id="fps-val">60 FPS</p></div>
                <div><p class="kpi-label">Poly Count</p><p class="kpi-value" id="poly-val">0 Tris</p></div>
                <div><p class="kpi-label">Entities</p><p class="kpi-value" id="obj-val">0</p></div>
                <div><p class="kpi-label">VRAM</p><p class="kpi-value" id="vram-val">0 MB</p></div>
                <div><p class="kpi-label">Engine</p><p class="kpi-value text-orange-500">MSSOG v6.0 ULTRA</p></div>
            </div>

            <!-- WORLD SETTINGS SHORTCUT -->
            <div class="absolute top-6 right-6 z-50 flex flex-col gap-2 ui-glass p-3 rounded-2xl">
                <select id="sky-select" onchange="updateWorld()" class="input-dark text-[9px]">
                    <option value="0x020202">VOID DARK</option>
                    <option value="0x111122">DEEP SEA</option>
                    <option value="0x221111">MARS RED</option>
                    <option value="0x222222">STUDIO</option>
                    <option value="0x112233">CYBER BLUE</option>
                </select>
                <button onclick="toggleGrid()" id="grid-btn" class="text-[9px] py-1 bg-zinc-900 rounded border border-zinc-800">GRID: ON</button>
                <button onclick="screenshot()" class="text-[9px] py-1 bg-orange-600/20 text-orange-400 rounded border border-orange-500/20">CAPTURE</button>
                <button onclick="togglePostFX()" id="postfx-btn" class="text-[9px] py-1 bg-purple-600/20 text-purple-400 rounded border border-purple-500/20">POSTFX: ON</button>
            </div>

            <!-- BOTTOM RIGHT: MINI MAP -->
            <div id="minimap" class="absolute bottom-6 right-6 z-40 w-32 h-32 bg-black/50 rounded-lg border border-zinc-800 overflow-hidden">
                <canvas id="minimap-canvas"></canvas>
            </div>
        </main>

        <!-- RIGHT: INSPECTOR -->
        <aside class="sidebar ui-glass border-l border-zinc-900 flex flex-col p-4 space-y-4 overflow-y-auto">
            <div class="flex gap-1 mb-4">
                <button onclick="switchTab('transform')" class="tab active">TRANSFORM</button>
                <button onclick="switchTab('material')" class="tab">MATERIAL</button>
                <button onclick="switchTab('physics')" class="tab">PHYSICS</button>
                <button onclick="switchTab('script')" class="tab">SCRIPT</button>
            </div>
            
            <div id="inspector-transform" class="space-y-4">
                <!-- Transform content will be loaded here -->
            </div>
            
            <div id="inspector-material" class="space-y-4 hidden">
                <!-- Material content will be loaded here -->
            </div>
            
            <div id="inspector-physics" class="space-y-4 hidden">
                <!-- Physics content will be loaded here -->
            </div>
            
            <div id="inspector-script" class="space-y-4 hidden">
                <!-- Script content will be loaded here -->
            </div>
        </aside>
    </div>

    <script>
        const ACCESS_PASS = "ssog123";
        let scene, camera, renderer, orbit, transformControl, raycaster, mouse, gridHelper, selectionBox, clock;
        let selectedObject = null;
        let mainGroup = new THREE.Group();
        let history = [], historyStep = -1;
        let snapEnabled = false;
        let isGridVisible = true;
        let symmetryEnabled = false;
        let physicsEnabled = false;
        let postFXEnabled = true;
        let composer, bloomPass, fxaaPass;
        let minimapCamera, minimapRenderer;

        // --- 30 FITUR UMUM TAMBAHAN ---
        const FEATURES = {
            // Scene Management
            autoSave: false,
            sceneVersioning: true,
            multiSelect: false,
            layerSystem: [],
            
            // Navigation
            flyMode: false,
            walkMode: false,
            cameraPaths: [],
            
            // Tools
            measuringTool: false,
            protractorTool: false,
            rulerTool: false,
            
            // Export
            exportFormats: ['GLB', 'GLTF', 'OBJ', 'FBX', 'STL', 'USDZ'],
            
            // AI Features
            autoUV: false,
            autoLOD: false,
            autoLighting: false,
            
            // Collaboration
            realtimeCollab: false,
            versionControl: false,
            commentSystem: false,
            
            // Rendering
            realtimeGI: false,
            raytracing: false,
            pathTracing: false,
            
            // Animation
            timelineEditor: false,
            keyframeAnimation: false,
            morphTargets: false,
            
            // Simulation
            clothSim: false,
            fluidSim: false,
            softBody: false,
            
            // AR/VR
            arPreview: false,
            vrPreview: false,
            webXR: false
        };

        // --- 30 FITUR MATERIAL TAMBAHAN ---
        const MATERIAL_TYPES = {
            PBR: ['Standard', 'Metallic', 'Roughness', 'Specular'],
            Special: ['Glass', 'Water', 'Ice', 'Lava', 'Hologram', 'Neon'],
            CarPaint: ['Metallic Flake', 'Pearlescent', 'Chameleon'],
            Fabric: ['Cotton', 'Silk', 'Denim', 'Leather'],
            Metal: ['Brushed Steel', 'Copper', 'Aluminum', 'Titanium'],
            Stone: ['Marble', 'Granite', 'Concrete', 'Brick'],
            Wood: ['Oak', 'Mahogany', 'Pine', 'Varnished'],
            Tech: ['Carbon Fiber', 'Circuit Board', 'OLED'],
            Emissive: ['Glow', 'Neon Tube', 'LED', 'Plasma'],
            Custom: ['Anisotropic', 'Clear Coat', 'Subsurface', 'Sheen']
        };

        // --- 30 FITUR 3D TAMBAHAN ---
        const GEOMETRY_FEATURES = {
            primitives: ['TorusKnot', 'Octahedron', 'Dodecahedron', 'Icosahedron'],
            splines: ['Bezier', 'NURBS', 'Catmull-Rom'],
            modifiers: ['Subdivision', 'Displace', 'Boolean', 'Lathe'],
            particles: ['Emitter', 'Force Fields', 'Collisions'],
            vegetation: ['Tree Generator', 'Grass', 'Foliage'],
            terrain: ['Heightmap', 'Erosion', 'Texturing'],
            water: ['Ocean', 'River', 'Pool'],
            sky: ['Procedural Sky', 'Atmosphere', 'Clouds'],
            lights: ['Area Light', 'Spot Light', 'IES Profile'],
            effects: ['Lens Flare', 'God Rays', 'Motion Blur']
        };

        // --- AUTH ---
        function checkAccess() {
            if (document.getElementById('password').value === ACCESS_PASS) {
                document.getElementById('login-screen').style.display = 'none';
                document.getElementById('editor-ui').classList.remove('hidden');
                initEngine();
            }
        }

        // --- CORE ENGINE ---
        function initEngine() {
            const container = document.getElementById('viewport');
            clock = new THREE.Clock();
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020202);
            scene.fog = new THREE.Fog(0x020202, 100, 500);
            scene.add(mainGroup);

            camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 5000);
            camera.position.set(20, 20, 20);

            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                preserveDrawingBuffer: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1;
            container.appendChild(renderer.domElement);

            // Post Processing
            composer = new THREE.EffectComposer(renderer);
            const renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);
            
            bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5, 0.4, 0.85
            );
            composer.addPass(bloomPass);
            
            fxaaPass = new THREE.ShaderPass(THREE.FXAAShader);
            composer.addPass(fxaaPass);

            // Grid
            gridHelper = new THREE.GridHelper(100, 50, 0xff4d00, 0x111111);
            gridHelper.material.transparent = true;
            gridHelper.material.opacity = 0.2;
            scene.add(gridHelper);

            // Orbit Controls
            orbit = new THREE.OrbitControls(camera, renderer.domElement);
            orbit.enableDamping = true;
            orbit.dampingFactor = 0.05;
            orbit.maxDistance = 1000;
            orbit.minDistance = 1;

            // Transform Control
            transformControl = new THREE.TransformControls(camera, renderer.domElement);
            transformControl.addEventListener('dragging-changed', (e) => {
                orbit.enabled = !e.value;
                if (!e.value) { 
                    saveHistory(); 
                    updateInspector();
                    if (symmetryEnabled) applySymmetry();
                }
            });
            scene.add(transformControl);

            // Selection Box
            selectionBox = new THREE.BoxHelper();
            selectionBox.material.color.set(0xff4d00);
            selectionBox.visible = false;
            scene.add(selectionBox);

            // Lights
            scene.add(new THREE.AmbientLight(0xffffff, 0.3));
            
            const sun = new THREE.DirectionalLight(0xffffff, 1);
            sun.position.set(50, 100, 50);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            sun.shadow.camera.near = 0.5;
            sun.shadow.camera.far = 500;
            scene.add(sun);

            // Fill Light
            const fillLight = new THREE.PointLight(0xffaa33, 0.5, 100);
            fillLight.position.set(-20, 20, -20);
            scene.add(fillLight);

            // Raycaster
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Minimap
            initMinimap();

            // Event Listeners
            window.addEventListener('mousedown', onSelect);
            window.addEventListener('resize', onResize);
            window.addEventListener('keydown', onKey);
            document.addEventListener('visibilitychange', autoSaveCheck);

            // Initial Scene
            createDefaultScene();
            animate();
            saveHistory();
        }

        function initMinimap() {
            const canvas = document.getElementById('minimap-canvas');
            minimapRenderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                antialias: false,
                alpha: true 
            });
            minimapRenderer.setSize(128, 128);
            minimapRenderer.setClearColor(0x000000, 0);
            
            minimapCamera = new THREE.OrthographicCamera(-50, 50, 50, -50, 1, 1000);
            minimapCamera.position.set(0, 100, 0);
            minimapCamera.lookAt(0, 0, 0);
        }

        function createDefaultScene() {
            // Add a ground plane
            const groundGeo = new THREE.PlaneGeometry(100, 100);
            const groundMat = new THREE.MeshStandardMaterial({ 
                color: 0x222222, 
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            ground.name = "Ground_Plane";
            mainGroup.add(ground);

            // Add some starter objects
            for(let i = 0; i < 3; i++) {
                const geo = new THREE.BoxGeometry(2, 2, 2);
                const mat = new THREE.MeshStandardMaterial({ 
                    color: Math.random() * 0xffffff,
                    metalness: Math.random(),
                    roughness: Math.random()
                });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(
                    (Math.random() - 0.5) * 20,
                    Math.random() * 5,
                    (Math.random() - 0.5) * 20
                );
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.name = `Object_${i}`;
                mainGroup.add(mesh);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            
            // Update orbit controls
            orbit.update();
            
            // Update selection box
            if (selectionBox.visible && selectedObject) {
                selectionBox.update();
            }
            
            // Update minimap
            updateMinimap();
            
            // Render
            if (postFXEnabled) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
            
            // Update KPI stats
            updateStats();
        }

        function updateStats() {
            const fps = Math.round(1 / clock.getDelta());
            document.getElementById('fps-val').innerText = `${fps} FPS`;
            
            // Poly count
            let tris = 0;
            let objs = 0;
            mainGroup.traverse((node) => {
                if (node.isMesh) {
                    if (node.geometry.index) {
                        tris += node.geometry.index.count / 3;
                    } else {
                        tris += node.geometry.attributes.position.count / 3;
                    }
                    objs++;
                }
            });
            document.getElementById('poly-val').innerText = `${Math.round(tris).toLocaleString()} Tris`;
            document.getElementById('obj-val').innerText = `${objs}`;
            
            // VRAM estimation
            const vram = Math.round((tris * 100) / 1000000);
            document.getElementById('vram-val').innerText = `${vram} MB`;
        }

        function updateMinimap() {
            minimapCamera.position.x = camera.position.x;
            minimapCamera.position.z = camera.position.z;
            minimapRenderer.render(scene, minimapCamera);
        }

        // --- 30 FITUR UMUM IMPLEMENTASI ---
        function centerAllObjects() {
            const bbox = new THREE.Box3();
            mainGroup.children.forEach(child => {
                bbox.expandByObject(child);
            });
            
            const center = bbox.getCenter(new THREE.Vector3());
            mainGroup.position.sub(center);
            saveHistory();
        }

        function randomizePositions() {
            mainGroup.children.forEach(child => {
                if (child !== gridHelper) {
                    child.position.set(
                        (Math.random() - 0.5) * 40,
                        Math.random() * 20,
                        (Math.random() - 0.5) * 40
                    );
                }
            });
            saveHistory();
        }

        function alignToGrid() {
            mainGroup.children.forEach(child => {
                if (child.isMesh) {
                    child.position.x = Math.round(child.position.x);
                    child.position.y = Math.round(child.position.y);
                    child.position.z = Math.round(child.position.z);
                }
            });
            saveHistory();
        }

        function toggleWireframeAll() {
            mainGroup.traverse(node => {
                if (node.isMesh) {
                    node.material.wireframe = !node.material.wireframe;
                }
            });
        }

        function createLightProbe() {
            const probe = new THREE.LightProbe();
            probe.name = "Light_Probe";
            mainGroup.add(probe);
            updateSceneTree();
            saveHistory();
        }

        function bakeSceneLighting() {
            alert("Light baking started... This feature requires additional setup with a baking engine.");
        }

        function generateTerrain() {
            const size = 100;
            const segments = 100;
            const geometry = new THREE.PlaneGeometry(size, size, segments, segments);
            
            const vertices = geometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                vertices[i + 2] = Math.random() * 10;
            }
            geometry.computeVertexNormals();
            
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x558855,
                roughness: 0.8,
                metalness: 0.1
            });
            
            const terrain = new THREE.Mesh(geometry, material);
            terrain.rotation.x = -Math.PI / 2;
            terrain.receiveShadow = true;
            terrain.castShadow = true;
            terrain.name = "Procedural_Terrain";
            mainGroup.add(terrain);
            
            saveHistory();
            updateSceneTree();
        }

        function createParticles() {
            const particleCount = 1000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 100;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 100;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
                
                colors[i * 3] = Math.random();
                colors[i * 3 + 1] = Math.random();
                colors[i * 3 + 2] = Math.random();
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.5,
                vertexColors: true,
                transparent: true,
                opacity: 0.8
            });
            
            const particles = new THREE.Points(geometry, material);
            particles.name = "Particle_System";
            mainGroup.add(particles);
            
            saveHistory();
            updateSceneTree();
        }

        function toggleSymmetry() {
            symmetryEnabled = !symmetryEnabled;
            alert(`Symmetry ${symmetryEnabled ? 'Enabled' : 'Disabled'}`);
        }

        function togglePhysics() {
            physicsEnabled = !physicsEnabled;
            alert(`Physics ${physicsEnabled ? 'Enabled' : 'Disabled'}`);
        }

        function toggleXR() {
            alert("XR Mode would require WebXR API implementation");
        }

        function togglePostFX() {
            postFXEnabled = !postFXEnabled;
            document.getElementById('postfx-btn').innerText = `POSTFX: ${postFXEnabled ? 'ON' : 'OFF'}`;
        }

        function applySymmetry() {
            if (!selectedObject || !symmetryEnabled) return;
            
            const clone = selectedObject.clone();
            clone.position.x = -selectedObject.position.x;
            clone.scale.x = -selectedObject.scale.x;
            mainGroup.add(clone);
            clone.name = selectedObject.name + "_SYM";
            
            saveHistory();
            updateSceneTree();
        }

        function autoSaveCheck() {
            if (FEATURES.autoSave && document.hidden) {
                autoSave();
            }
        }

        function autoSave() {
            localStorage.setItem('mssog_autosave', JSON.stringify(mainGroup.toJSON()));
            console.log("Auto-saved scene");
        }

        // --- 30 FITUR MATERIAL IMPLEMENTASI ---
        function applyMaterialPreset(preset) {
            if (!selectedObject || !selectedObject.isMesh) return;
            
            const mat = selectedObject.material;
            
            switch(preset) {
                case 'glass':
                    mat.transparent = true;
                    mat.opacity = 0.3;
                    mat.roughness = 0;
                    mat.metalness = 0;
                    mat.ior = 1.5;
                    break;
                    
                case 'water':
                    mat.color.set(0x0088ff);
                    mat.transparent = true;
                    mat.opacity = 0.5;
                    mat.roughness = 0.1;
                    mat.metalness = 0.8;
                    break;
                    
                case 'metal':
                    mat.roughness = 0.2;
                    mat.metalness = 1;
                    break;
                    
                case 'plastic':
                    mat.roughness = 0.8;
                    mat.metalness = 0;
                    break;
                    
                case 'rubber':
                    mat.roughness = 1;
                    mat.metalness = 0;
                    break;
                    
                case 'emissive':
                    mat.emissive.set(mat.color);
                    mat.emissiveIntensity = 2;
                    break;
                    
                case 'hologram':
                    mat.transparent = true;
                    mat.opacity = 0.3;
                    mat.emissive.set(0x00ff00);
                    mat.emissiveIntensity = 3;
                    mat.wireframe = true;
                    break;
                    
                case 'neon':
                    mat.emissive.set(mat.color);
                    mat.emissiveIntensity = 5;
                    mat.roughness = 0.1;
                    break;
                    
                case 'carbon_fiber':
                    // This would require a texture
                    mat.roughness = 0.3;
                    mat.metalness = 0.8;
                    break;
                    
                case 'lava':
                    mat.emissive.set(0xff3300);
                    mat.emissiveIntensity = 3;
                    mat.roughness = 0.8;
                    break;
            }
            
            mat.needsUpdate = true;
            updateInspector();
            saveHistory();
        }

        function generateProceduralMaterial() {
            if (!selectedObject || !selectedObject.isMesh) return;
            
            const mat = selectedObject.material;
            
            // Create a procedural pattern
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Generate noise/pattern
            for(let x = 0; x < 512; x += 4) {
                for(let y = 0; y < 512; y += 4) {
                    const value = Math.random() * 255;
                    ctx.fillStyle = `rgb(${value},${value},${value})`;
                    ctx.fillRect(x, y, 4, 4);
                }
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(4, 4);
            
            mat.map = texture;
            mat.needsUpdate = true;
            
            saveHistory();
            updateInspector();
        }

        // --- HIERARCHY & ASSETS ---
        function updateSceneTree() {
            const tree = document.getElementById('scene-tree');
            const search = document.getElementById('tree-search').value.toLowerCase();
            tree.innerHTML = "";

            const renderNode = (node, depth = 0) => {
                if (node.name.toLowerCase().indexOf(search) === -1 && search !== "") return;
                
                const item = document.createElement('div');
                item.className = `tree-item ${selectedObject === node ? 'selected' : ''}`;
                item.style.paddingLeft = `${depth * 16 + 12}px`;
                
                const isFolder = node.userData?.isFolder;
                const icon = isFolder ? 'üìÅ' : 
                            node.isLight ? 'üí°' :
                            node.isCamera ? 'üì∑' :
                            node.isMesh ? 'üßä' : '‚öôÔ∏è';
                
                item.innerHTML = `
                    <span>${icon}</span>
                    <span class="flex-1 truncate">${node.name || 'Unnamed'}</span>
                    ${node.visible ? '' : '<span class="text-[8px] opacity-40">HIDDEN</span>'}
                    ${node.children?.length > 0 ? `<span class="text-[8px] opacity-40">${node.children.length}</span>` : ''}
                `;
                
                item.onclick = (e) => { 
                    e.stopPropagation(); 
                    selectObject(node); 
                };
                tree.appendChild(item);

                if (node.children) {
                    node.children.forEach(c => {
                        if (c !== transformControl && c !== selectionBox) renderNode(c, depth + 1);
                    });
                }
            };

            mainGroup.children.forEach(c => renderNode(c));
        }

        function selectObject(obj) {
            selectedObject = obj;
            if (obj && !obj.userData?.isFolder) {
                transformControl.attach(obj);
                selectionBox.setFromObject(obj);
                selectionBox.visible = true;
            } else {
                transformControl.detach();
                selectionBox.visible = false;
            }
            updateSceneTree();
            updateInspector();
        }

        // --- PRIMITIVES ---
        function addPrimitive(type) {
            let geo;
            switch(type) {
                case 'cube':
                    geo = new THREE.BoxGeometry(2, 2, 2);
                    break;
                case 'sphere':
                    geo = new THREE.SphereGeometry(1.5, 32, 32);
                    break;
                case 'plane':
                    geo = new THREE.PlaneGeometry(10, 10);
                    break;
                case 'cylinder':
                    geo = new THREE.CylinderGeometry(1, 1, 3, 32);
                    break;
                case 'cone':
                    geo = new THREE.ConeGeometry(1.5, 3, 32);
                    break;
                case 'torus':
                    geo = new THREE.TorusGeometry(1.5, 0.5, 16, 100);
                    break;
                case 'torusknot':
                    geo = new THREE.TorusKnotGeometry(1.5, 0.5, 100, 16);
                    break;
                case 'octahedron':
                    geo = new THREE.OctahedronGeometry(1.5);
                    break;
                case 'dodecahedron':
                    geo = new THREE.DodecahedronGeometry(1.5);
                    break;
                case 'icosahedron':
                    geo = new THREE.IcosahedronGeometry(1.5);
                    break;
                default:
                    geo = new THREE.BoxGeometry(2, 2, 2);
            }

            const mat = new THREE.MeshStandardMaterial({ 
                color: 0x888888, 
                metalness: 0.2, 
                roughness: 0.8,
                side: THREE.DoubleSide
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.name = type.toUpperCase() + "_" + Math.floor(Math.random() * 1000);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            // Random position near center
            mesh.position.set(
                (Math.random() - 0.5) * 10,
                Math.random() * 5,
                (Math.random() - 0.5) * 10
            );
            
            mainGroup.add(mesh);
            selectObject(mesh);
            saveHistory();
        }

        function addFolder() {
            const g = new THREE.Group();
            g.name = "FOLDER_" + Math.floor(Math.random() * 100);
            g.userData = { isFolder: true };
            mainGroup.add(g);
            updateSceneTree();
            saveHistory();
        }

        function handleGlbUpload() {
            const f = document.getElementById('glb-input').files[0];
            if (!f) return;
            const loader = new THREE.GLTFLoader();
            loader.load(URL.createObjectURL(f), (gltf) => {
                const model = gltf.scene;
                model.name = f.name.split('.')[0];
                
                // Enable shadows for all meshes
                model.traverse(node => {
                    if (node.isMesh) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                    }
                });
                
                mainGroup.add(model);
                updateSceneTree();
                saveHistory();
            });
        }

        // --- INSPECTOR ---
        function switchTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('[id^="inspector-"]').forEach(el => {
                el.classList.add('hidden');
            });
            // Remove active class from all tabs
            document.querySelectorAll('.tab').forEach(t => {
                t.classList.remove('active');
            });
            // Show selected tab
            document.getElementById(`inspector-${tabName}`).classList.remove('hidden');
            // Set active tab
            event.target.classList.add('active');
            
            // Update content if needed
            if (tabName === 'material') {
                updateMaterialTab();
            }
        }

        function updateInspector() {
            if (!selectedObject) {
                document.getElementById('inspector-transform').innerHTML = 
                    `<div class="text-center py-20 text-zinc-800 text-[10px] italic">Select an entity</div>`;
                return;
            }

            updateTransformTab();
        }

        function updateTransformTab() {
            const isMesh = selectedObject.isMesh;
            const panel = document.getElementById('inspector-transform');
            
            panel.innerHTML = `
                <div class="space-y-4 animate-in fade-in">
                    <section class="inspector-section">
                        <label class="kpi-label">Entity Properties</label>
                        <input type="text" value="${selectedObject.name}" onchange="editProp('name', this.value)" class="input-dark mb-2">
                        
                        <div class="grid-row">
                            <div>
                                <p class="text-[7px] text-zinc-600">Visible</p>
                                <input type="checkbox" ${selectedObject.visible ? 'checked' : ''} onchange="editProp('visible', this.checked)" class="mt-1">
                            </div>
                            <div>
                                <p class="text-[7px] text-zinc-600">Cast Shadow</p>
                                <input type="checkbox" ${selectedObject.castShadow ? 'checked' : ''} onchange="editProp('castShadow', this.checked)" class="mt-1">
                            </div>
                        </div>
                    </section>

                    <section class="inspector-section">
                        <label class="kpi-label">Transform</label>
                        <div class="grid grid-cols-3 gap-2 mb-2">
                            <div><p class="text-[7px] text-zinc-600 mb-1">POS X</p><input type="number" step="0.1" value="${selectedObject.position.x.toFixed(2)}" onchange="editProp('px', this.value)" class="input-dark"></div>
                            <div><p class="text-[7px] text-zinc-600 mb-1">POS Y</p><input type="number" step="0.1" value="${selectedObject.position.y.toFixed(2)}" onchange="editProp('py', this.value)" class="input-dark"></div>
                            <div><p class="text-[7px] text-zinc-600 mb-1">POS Z</p><input type="number" step="0.1" value="${selectedObject.position.z.toFixed(2)}" onchange="editProp('pz', this.value)" class="input-dark"></div>
                        </div>
                        
                        <div class="grid grid-cols-3 gap-2 mb-2">
                            <div><p class="text-[7px] text-zinc-600 mb-1">ROT X</p><input type="number" step="0.1" value="${THREE.MathUtils.radToDeg(selectedObject.rotation.x).toFixed(1)}" onchange="editProp('rx', this.value)" class="input-dark"></div>
                            <div><p class="text-[7px] text-zinc-600 mb-1">ROT Y</p><input type="number" step="0.1" value="${THREE.MathUtils.radToDeg(selectedObject.rotation.y).toFixed(1)}" onchange="editProp('ry', this.value)" class="input-dark"></div>
                            <div><p class="text-[7px] text-zinc-600 mb-1">ROT Z</p><input type="number" step="0.1" value="${THREE.MathUtils.radToDeg(selectedObject.rotation.z).toFixed(1)}" onchange="editProp('rz', this.value)" class="input-dark"></div>
                        </div>
                        
                        <div class="grid grid-cols-3 gap-2">
                            <div><p class="text-[7px] text-zinc-600 mb-1">SCALE X</p><input type="number" step="0.1" value="${selectedObject.scale.x.toFixed(2)}" onchange="editProp('sx', this.value)" class="input-dark"></div>
                            <div><p class="text-[7px] text-zinc-600 mb-1">SCALE Y</p><input type="number" step="0.1" value="${selectedObject.scale.y.toFixed(2)}" onchange="editProp('sy', this.value)" class="input-dark"></div>
                            <div><p class="text-[7px] text-zinc-600 mb-1">SCALE Z</p><input type="number" step="0.1" value="${selectedObject.scale.z.toFixed(2)}" onchange="editProp('sz', this.value)" class="input-dark"></div>
                        </div>
                    </section>

                    ${isMesh ? `
                    <section class="inspector-section">
                        <label class="kpi-label">Geometry</label>
                        <div class="grid-row">
                            <div>
                                <p class="text-[7px] text-zinc-600">Wireframe</p>
                                <input type="checkbox" ${selectedObject.material.wireframe ? 'checked' : ''} onchange="editProp('wire', this.checked)" class="mt-1">
                            </div>
                            <div>
                                <p class="text-[7px] text-zinc-600">Double Side</p>
                                <input type="checkbox" ${selectedObject.material.side === THREE.DoubleSide ? 'checked' : ''} onchange="editProp('doubleSide', this.checked)" class="mt-1">
                            </div>
                        </div>
                    </section>
                    ` : ''}

                    <section>
                        <button onclick="deleteObject()" class="w-full py-3 bg-red-950/20 text-red-500 border border-red-950/30 text-[9px] font-bold rounded-xl hover:bg-red-600 hover:text-white transition-all">DELETE ENTITY</button>
                    </section>
                </div>
            `;
        }

        function updateMaterialTab() {
            if (!selectedObject || !selectedObject.isMesh) {
                document.getElementById('inspector-material').innerHTML = 
                    `<div class="text-center py-20 text-zinc-800 text-[10px] italic">Select a mesh to edit material</div>`;
                return;
            }

            const mat = selectedObject.material;
            const panel = document.getElementById('inspector-material');
            
            panel.innerHTML = `
                <div class="space-y-4">
                    <section class="inspector-section">
                        <label class="kpi-label">Material Presets</label>
                        <div class="grid grid-cols-3 gap-1">
                            <button onclick="applyMaterialPreset('glass')" class="py-2 bg-zinc-900 text-[8px] rounded hover:border-blue-500 border border-zinc-800">GLASS</button>
                            <button onclick="applyMaterialPreset('metal')" class="py-2 bg-zinc-900 text-[8px] rounded hover:border-gray-500 border border-zinc-800">METAL</button>
                            <button onclick="applyMaterialPreset('plastic')" class="py-2 bg-zinc-900 text-[8px] rounded hover:border-white border border-zinc-800">PLASTIC</button>
                            <button onclick="applyMaterialPreset('rubber')" class="py-2 bg-zinc-900 text-[8px] rounded hover:border-black border border-zinc-800">RUBBER</button>
                            <button onclick="applyMaterialPreset('water')" class="py-2 bg-zinc-900 text-[8px] rounded hover:border-cyan-500 border border-zinc-800">WATER</button>
                            <button onclick="applyMaterialPreset('emissive')" class="py-2 bg-zinc-900 text-[8px] rounded hover:border-yellow-500 border border-zinc-800">EMISSIVE</button>
                            <button onclick="applyMaterialPreset('hologram')" class="py-2 bg-zinc-900 text-[8px] rounded hover:border-green-500 border border-zinc-800">HOLOGRAM</button>
                            <button onclick="applyMaterialPreset('neon')" class="py-2 bg-zinc-900 text-[8px] rounded hover:border-pink-500 border border-zinc-800">NEON</button>
                            <button onclick="applyMaterialPreset('lava')" class="py-2 bg-zinc-900 text-[8px] rounded hover:border-red-500 border border-zinc-800">LAVA</button>
                        </div>
                    </section>

                    <section class="inspector-section">
                        <label class="kpi-label">Base Color</label>
                        <div class="flex items-center gap-3 mb-3">
                            <input type="color" value="#${mat.color.getHexString()}" onchange="editProp('color', this.value)" class="w-10 h-10 bg-transparent border-none cursor-pointer">
                            <div class="flex-1">
                                <p class="text-[8px] text-zinc-500">HEX: #${mat.color.getHexString().toUpperCase()}</p>
                                <p class="text-[8px] text-zinc-700">RGB: ${mat.color.r.toFixed(2)}, ${mat.color.g.toFixed(2)}, ${mat.color.b.toFixed(2)}</p>
                            </div>
                        </div>
                        
                        <button onclick="generateProceduralMaterial()" class="w-full py-2 bg-zinc-900 border border-zinc-800 text-[9px] hover:border-orange-500 rounded-lg">GENERATE PROCEDURAL</button>
                    </section>

                    <section class="inspector-section">
                        <label class="kpi-label">PBR Properties</label>
                        <div class="space-y-3">
                            <div>
                                <p class="text-[7px] text-zinc-600 mb-1">Metalness: ${mat.metalness.toFixed(2)}</p>
                                <input type="range" min="0" max="1" step="0.01" value="${mat.metalness}" oninput="editProp('metal', this.value)" class="w-full">
                            </div>
                            <div>
                                <p class="text-[7px] text-zinc-600 mb-1">Roughness: ${mat.roughness.toFixed(2)}</p>
                                <input type="range" min="0" max="1" step="0.01" value="${mat.roughness}" oninput="editProp('rough', this.value)" class="w-full">
                            </div>
                        </div>
                    </section>

                    <section class="inspector-section">
                        <label class="kpi-label">Advanced</label>
                        <div class="grid-row">
                            <div>
                                <p class="text-[7px] text-zinc-600">Emissive</p>
                                <input type="color" value="#${mat.emissive.getHexString()}" onchange="editProp('emissive', this.value)" class="w-full h-8 bg-transparent border border-zinc-800 rounded">
                            </div>
                            <div>
                                <p class="text-[7px] text-zinc-600">Intensity: ${mat.emissiveIntensity?.toFixed(1) || '0'}</p>
                                <input type="range" min="0" max="10" step="0.1" value="${mat.emissiveIntensity || 0}" oninput="editProp('emissiveIntensity', this.value)" class="w-full">
                            </div>
                        </div>
                        
                        <div class="grid-row mt-3">
                            <div>
                                <p class="text-[7px] text-zinc-600">Opacity: ${mat.opacity?.toFixed(2) || '1.00'}</p>
                                <input type="range" min="0" max="1" step="0.01" value="${mat.opacity || 1}" oninput="editProp('opacity', this.value)" class="w-full">
                            </div>
                            <div>
                                <p class="text-[7px] text-zinc-600">Transmission: ${mat.transmission?.toFixed(2) || '0'}</p>
                                <input type="range" min="0" max="1" step="0.01" value="${mat.transmission || 0}" oninput="editProp('transmission', this.value)" class="w-full">
                            </div>
                        </div>
                    </section>

                    <section>
                        <label class="kpi-label">Texture Maps</label>
                        <div class="space-y-2">
                            <div class="grid grid-cols-2 gap-1">
                                <button onclick="uploadTexture('albedo')" class="py-2 bg-zinc-900 text-[8px] rounded hover:border-blue-500 border border-zinc-800">ALBEDO</button>
                                <button onclick="uploadTexture('normal')" class="py-2 bg-zinc-900 text-[8px] rounded hover:border-green-500 border border-zinc-800">NORMAL</button>
                                <button onclick="uploadTexture('roughness')" class="py-2 bg-zinc-900 text-[8px] rounded hover:border-yellow-500 border border-zinc-800">ROUGHNESS</button>
                                <button onclick="uploadTexture('metalness')" class="py-2 bg-zinc-900 text-[8px] rounded hover:border-gray-500 border border-zinc-800">METALNESS</button>
                                <button onclick="uploadTexture('ao')" class="py-2 bg-zinc-900 text-[8px] rounded hover:border-red-500 border border-zinc-800">AO</button>
                                <button onclick="uploadTexture('emissive')" class="py-2 bg-zinc-900 text-[8px] rounded hover:border-pink-500 border border-zinc-800">EMISSIVE</button>
                            </div>
                            <input type="file" id="texture-file-input" class="hidden" accept="image/*" onchange="handleTextureUpload(event)">
                        </div>
                    </section>
                </div>
            `;
        }

        function editProp(prop, val) {
            if (!selectedObject) return;
            
            switch(prop) {
                case 'name':
                    selectedObject.name = val;
                    break;
                case 'px':
                    selectedObject.position.x = parseFloat(val);
                    break;
                case 'py':
                    selectedObject.position.y = parseFloat(val);
                    break;
                case 'pz':
                    selectedObject.position.z = parseFloat(val);
                    break;
                case 'rx':
                    selectedObject.rotation.x = THREE.MathUtils.degToRad(parseFloat(val));
                    break;
                case 'ry':
                    selectedObject.rotation.y = THREE.MathUtils.degToRad(parseFloat(val));
                    break;
                case 'rz':
                    selectedObject.rotation.z = THREE.MathUtils.degToRad(parseFloat(val));
                    break;
                case 'sx':
                    selectedObject.scale.x = parseFloat(val);
                    break;
                case 'sy':
                    selectedObject.scale.y = parseFloat(val);
                    break;
                case 'sz':
                    selectedObject.scale.z = parseFloat(val);
                    break;
                case 'visible':
                    selectedObject.visible = val;
                    break;
                case 'castShadow':
                    selectedObject.castShadow = val;
                    break;
                case 'wire':
                    if (selectedObject.isMesh) selectedObject.material.wireframe = val;
                    break;
                case 'doubleSide':
                    if (selectedObject.isMesh) selectedObject.material.side = val ? THREE.DoubleSide : THREE.FrontSide;
                    break;
                case 'color':
                    if (selectedObject.isMesh) selectedObject.material.color.set(val);
                    break;
                case 'metal':
                    if (selectedObject.isMesh) selectedObject.material.metalness = parseFloat(val);
                    break;
                case 'rough':
                    if (selectedObject.isMesh) selectedObject.material.roughness = parseFloat(val);
                    break;
                case 'emissive':
                    if (selectedObject.isMesh) selectedObject.material.emissive.set(val);
                    break;
                case 'emissiveIntensity':
                    if (selectedObject.isMesh) selectedObject.material.emissiveIntensity = parseFloat(val);
                    break;
                case 'opacity':
                    if (selectedObject.isMesh) {
                        selectedObject.material.opacity = parseFloat(val);
                        selectedObject.material.transparent = val < 1;
                    }
                    break;
                case 'transmission':
                    if (selectedObject.isMesh) selectedObject.material.transmission = parseFloat(val);
                    break;
            }

            if (selectedObject.isMesh) selectedObject.material.needsUpdate = true;
            
            updateSceneTree();
            updateInspector();
            saveHistory();
        }

        let currentTextureType = 'albedo';
        function uploadTexture(type) {
            currentTextureType = type;
            document.getElementById('texture-file-input').click();
        }

        function handleTextureUpload(event) {
            const file = event.target.files[0];
            if (!file || !selectedObject || !selectedObject.isMesh) return;
            
            const loader = new THREE.TextureLoader();
            loader.load(URL.createObjectURL(file), (texture) => {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                
                const mat = selectedObject.material;
                switch(currentTextureType) {
                    case 'albedo':
                        mat.map = texture;
                        break;
                    case 'normal':
                        mat.normalMap = texture;
                        mat.normalScale = new THREE.Vector2(1, 1);
                        break;
                    case 'roughness':
                        mat.roughnessMap = texture;
                        break;
                    case 'metalness':
                        mat.metalnessMap = texture;
                        break;
                    case 'ao':
                        mat.aoMap = texture;
                        break;
                    case 'emissive':
                        mat.emissiveMap = texture;
                        break;
                }
                
                mat.needsUpdate = true;
                updateInspector();
                saveHistory();
            });
        }

        // --- ACTIONS & TOOLS ---
        function deleteObject() {
            if (!selectedObject || selectedObject === gridHelper) return;
            
            if (confirm(`Delete "${selectedObject.name}"?`)) {
                const obj = selectedObject;
                transformControl.detach();
                obj.parent.remove(obj);
                selectedObject = null;
                selectionBox.visible = false;
                updateSceneTree();
                updateInspector();
                saveHistory();
            }
        }

        function duplicateObject() {
            if (!selectedObject) return;
            
            const clone = selectedObject.clone();
            
            // Clone materials if mesh
            if (clone.isMesh) {
                clone.material = selectedObject.material.clone();
            }
            
            // Offset position
            clone.position.x += 2;
            clone.position.z += 2;
            clone.name = selectedObject.name + "_COPY";
            
            mainGroup.add(clone);
            selectObject(clone);
            saveHistory();
        }

        function setToolMode(mode) {
            transformControl.setMode(mode);
            document.querySelectorAll('#editor-ui button').forEach(btn => {
                if (btn.id && btn.id.startsWith('tool-')) {
                    btn.classList.remove('active-tool');
                }
            });
            document.getElementById('tool-' + mode).classList.add('active-tool');
        }

        function toggleSnap() {
            snapEnabled = !snapEnabled;
            transformControl.setTranslationSnap(snapEnabled ? 1 : null);
            transformControl.setRotationSnap(snapEnabled ? THREE.MathUtils.degToRad(15) : null);
            transformControl.setScaleSnap(snapEnabled ? 0.25 : null);
            
            const btn = document.getElementById('snap-btn');
            btn.innerText = snapEnabled ? "SNAP: ON" : "SNAP: OFF";
            btn.classList.toggle('active-tool', snapEnabled);
        }

        function toggleGrid() {
            isGridVisible = !isGridVisible;
            gridHelper.visible = isGridVisible;
            document.getElementById('grid-btn').innerText = `GRID: ${isGridVisible ? 'ON' : 'OFF'}`;
        }

        function updateWorld() {
            const color = document.getElementById('sky-select').value;
            scene.background.set(parseInt(color));
            scene.fog.color.set(parseInt(color));
        }

        function exportScene() {
            const data = {
                metadata: {
                    version: 6.0,
                    generator: "MSSOG Engine",
                    date: new Date().toISOString()
                },
                scene: mainGroup.toJSON()
            };
            
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `MSSOG_Scene_${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        function clearScene() {
            if (confirm("Clear entire scene? This cannot be undone.")) {
                while(mainGroup.children.length > 0) {
                    mainGroup.remove(mainGroup.children[0]);
                }
                createDefaultScene();
                selectObject(null);
                saveHistory();
            }
        }

        function screenshot() {
            renderer.render(scene, camera);
            const link = document.createElement('a');
            link.download = `MSSOG_Render_${Date.now()}.png`;
            link.href = renderer.domElement.toDataURL("image/png");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // --- HISTORY ---
        function saveHistory() {
            if (historyStep < history.length - 1) {
                history = history.slice(0, historyStep + 1);
            }
            
            const state = {
                scene: mainGroup.toJSON(),
                camera: {
                    position: camera.position.toArray(),
                    rotation: camera.rotation.toArray()
                }
            };
            
            history.push(JSON.stringify(state));
            
            // Limit history size
            if (history.length > 100) {
                history.shift();
            }
            
            historyStep = history.length - 1;
        }

        function undo() {
            if (historyStep > 0) {
                historyStep--;
                applyState(history[historyStep]);
            }
        }

        function redo() {
            if (historyStep < history.length - 1) {
                historyStep++;
                applyState(history[historyStep]);
            }
        }

        function applyState(json) {
            try {
                const state = JSON.parse(json);
                const loader = new THREE.ObjectLoader();
                
                // Clear current scene
                while(mainGroup.children.length > 0) {
                    mainGroup.remove(mainGroup.children[0]);
                }
                
                // Load new scene
                loader.parse(state.scene, (obj) => {
                    obj.children.forEach(child => {
                        mainGroup.add(child);
                    });
                    
                    // Restore camera if available
                    if (state.camera) {
                        camera.position.fromArray(state.camera.position);
                        camera.rotation.fromArray(state.camera.rotation);
                        orbit.update();
                    }
                    
                    updateSceneTree();
                    if (selectedObject) {
                        // Try to reselect the object by name
                        const objName = selectedObject.name;
                        mainGroup.traverse(node => {
                            if (node.name === objName) {
                                selectObject(node);
                            }
                        });
                    }
                });
            } catch (error) {
                console.error("Error loading state:", error);
            }
        }

        // --- EVENT HANDLERS ---
        function onSelect(event) {
            // Don't select if clicking on UI elements
            if (event.target.closest('aside') || 
                event.target.closest('.absolute') || 
                event.target.closest('#toolbar')) {
                return;
            }
            
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            // Filter objects that can be selected
            const selectableObjects = [];
            mainGroup.traverse(node => {
                if (node.isMesh && node.visible) {
                    selectableObjects.push(node);
                }
            });
            
            const intersects = raycaster.intersectObjects(selectableObjects);
            
            if (intersects.length > 0) {
                selectObject(intersects[0].object);
            } else {
                // Deselect if clicking empty space
                selectObject(null);
            }
        }

        function onKey(event) {
            // Tool shortcuts
            if (event.key === 'g' || event.key === 'G') {
                event.preventDefault();
                setToolMode('translate');
            }
            if (event.key === 'r' || event.key === 'R') {
                event.preventDefault();
                setToolMode('rotate');
            }
            if (event.key === 's' || event.key === 'S') {
                event.preventDefault();
                setToolMode('scale');
            }
            
            // Delete selected object
            if (event.key === 'Delete' || event.key === 'Backspace') {
                event.preventDefault();
                deleteObject();
            }
            
            // Undo/Redo
            if (event.ctrlKey || event.metaKey) {
                if (event.key === 'z') {
                    event.preventDefault();
                    undo();
                }
                if (event.key === 'y' || (event.shiftKey && event.key === 'Z')) {
                    event.preventDefault();
                    redo();
                }
                if (event.key === 'd') {
                    event.preventDefault();
                    duplicateObject();
                }
                if (event.key === 's') {
                    event.preventDefault();
                    exportScene();
                }
            }
            
            // Focus on selected object
            if (event.key === 'f' || event.key === 'F') {
                event.preventDefault();
                if (selectedObject) {
                    const box = new THREE.Box3().setFromObject(selectedObject);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    
                    orbit.target.copy(center);
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const fov = camera.fov * (Math.PI / 180);
                    let cameraZ = Math.abs(maxDim / Math.sin(fov / 2));
                    
                    cameraZ *= 1.5; // Add some margin
                    camera.position.copy(center);
                    camera.position.z += cameraZ;
                    orbit.update();
                }
            }
            
            // Toggle grid
            if (event.key === 'h' || event.key === 'H') {
                event.preventDefault();
                toggleGrid();
            }
            
            // Toggle wireframe
            if (event.key === 'w' || event.key === 'W') {
                event.preventDefault();
                if (selectedObject && selectedObject.isMesh) {
                    editProp('wire', !selectedObject.material.wireframe);
                }
            }
        }

        function onResize() {
            const container = document.getElementById('viewport');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
            composer.setSize(container.clientWidth, container.clientHeight);
            
            // Update minimap position
            const minimap = document.getElementById('minimap');
            minimap.style.right = '20px';
            minimap.style.bottom = '20px';
        }

        // --- 30 FITUR 3D IMPLEMENTASI TAMBAHAN ---
        // Note: Some features require additional libraries or complex implementations
        // Here are simplified versions

        function createSplinePath() {
            const curve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(-10, 0, 0),
                new THREE.Vector3(-5, 5, 0),
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(5, -5, 0),
                new THREE.Vector3(10, 0, 0)
            ]);
            
            const points = curve.getPoints(50);
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color: 0xff4d00 });
            const spline = new THREE.Line(geometry, material);
            spline.name = "Spline_Path";
            mainGroup.add(spline);
            
            saveHistory();
            updateSceneTree();
        }

        function createAreaLight() {
            const light = new THREE.RectAreaLight(0xffffff, 5, 10, 10);
            light.position.set(0, 10, 0);
            light.rotation.x = -Math.PI / 2;
            light.name = "Area_Light";
            mainGroup.add(light);
            
            saveHistory();
            updateSceneTree();
        }

        function createLensFlare() {
            const textureLoader = new THREE.TextureLoader();
            const flareTexture = textureLoader.load('https://threejs.org/examples/textures/lensflare/lensflare0.png');
            
            const flareSize = 100;
            const flareColor = new THREE.Color(0xffffff);
            
            const lensFlare = new THREE.Sprite(
                new THREE.SpriteMaterial({
                    map: flareTexture,
                    color: flareColor,
                    transparent: true,
                    opacity: 0.7
                })
            );
            
            lensFlare.scale.set(flareSize, flareSize, 1);
            lensFlare.position.set(50, 50, 50);
            lensFlare.name = "Lens_Flare";
            mainGroup.add(lensFlare);
            
            saveHistory();
            updateSceneTree();
        }

        function createAtmosphere() {
            const skyGeo = new THREE.SphereGeometry(500, 32, 32);
            const skyMat = new THREE.ShaderMaterial({
                uniforms: {
                    turbidity: { value: 10 },
                    rayleigh: { value: 2 },
                    mieCoefficient: { value: 0.005 },
                    mieDirectionalG: { value: 0.8 },
                    sunPosition: { value: new THREE.Vector3() }
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float turbidity;
                    uniform float rayleigh;
                    uniform float mieCoefficient;
                    uniform float mieDirectionalG;
                    uniform vec3 sunPosition;
                    varying vec3 vWorldPosition;
                    void main() {
                        float sunfade = 1.0 - clamp(1.0 - exp((sunPosition.y / 450000.0)), 0.0, 1.0);
                        float rayleighCoefficient = rayleigh - (1.0 * (1.0 - sunfade));
                        vec3 betaR = vec3(5.5e-6, 13.0e-6, 22.4e-6) * rayleighCoefficient;
                        vec3 betaM = vec3(21e-6) * mieCoefficient;
                        float zenithAngle = acos(max(0.0, dot(normalize(vWorldPosition), vec3(0.0, 1.0, 0.0))));
                        float sR = rayleighCoefficient / (cos(zenithAngle) + 0.15 * pow(93.885 - degrees(zenithAngle), -1.253));
                        float sM = mieCoefficient / (cos(zenithAngle) + 0.15 * pow(93.885 - degrees(zenithAngle), -1.253));
                        vec3 Fex = exp(-(betaR * sR + betaM * sM));
                        gl_FragColor = vec4(mix(vec3(1.0) - Fex, vec3(1.0), sunfade), 1.0);
                    }
                `,
                side: THREE.BackSide
            });
            
            const sky = new THREE.Mesh(skyGeo, skyMat);
            sky.name = "Atmosphere";
            scene.add(sky);
            
            saveHistory();
            updateSceneTree();
        }

        function createOcean() {
            const waterGeometry = new THREE.PlaneGeometry(1000, 1000, 128, 128);
            
            const waterMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0.0 }
                },
                vertexShader: `
                    uniform float time;
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        vec3 pos = position;
                        pos.y += sin(pos.x * 0.1 + time) * 0.5 + sin(pos.z * 0.1 + time) * 0.5;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    varying vec2 vUv;
                    void main() {
                        vec3 color = mix(vec3(0.0, 0.1, 0.3), vec3(0.0, 0.3, 0.6), vUv.y);
                        gl_FragColor = vec4(color, 0.8);
                    }
                `,
                transparent: true
            });
            
            const water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.rotation.x = -Math.PI / 2;
            water.position.y = -5;
            water.name = "Ocean";
            mainGroup.add(water);
            
            // Animate in render loop
            const animateWater = () => {
                if (water.material.uniforms.time) {
                    water.material.uniforms.time.value += 0.01;
                }
            };
            // This would need to be integrated into the main animation loop
            
            saveHistory();
            updateSceneTree();
        }

        // Initialize when page loads
        window.addEventListener('DOMContentLoaded', () => {
            // Set up password input to submit on Enter
            document.getElementById('password').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    checkAccess();
                }
            });
        });
    </script>
</body>
</html>
