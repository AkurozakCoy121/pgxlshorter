<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MSSOG ENGINE v6.0 ULTRA - Quantum 3D Suite</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;700&display=swap');
        body {
            font-family: 'JetBrains+Mono', monospace;
            background-color: #000;
            color: #ccc;
            overflow: hidden;
            user-select: none;
        }
        .ui-glass {
            background: rgba(10, 10, 10, 0.95);
            backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 77, 0, 0.1);
        }
        .sidebar { width: 340px; height: 100vh; z-index: 50; transition: width 0.3s; }
        .active-tool { background: #ff4d00 !important; color: white !important; box-shadow: 0 0 20px rgba(255, 77, 0, 0.3); }
        .input-dark {
            background: #0d0d0d;
            border: 1px solid #222;
            font-size: 10px;
            padding: 8px;
            border-radius: 6px;
            outline: none;
            color: #eee;
            width: 100%;
        }
        .input-dark:focus { border-color: #ff4d00; }
        .tree-item { 
            padding: 8px 12px; 
            font-size: 10px; 
            cursor: pointer; 
            display: flex; 
            align-items: center; 
            gap: 8px; 
            border-bottom: 1px solid rgba(255,255,255,0.02);
        }
        .tree-item:hover { background: rgba(255, 77, 0, 0.05); }
        .tree-item.selected { background: rgba(255, 77, 0, 0.15); border-left: 3px solid #ff4d00; }
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: #ff4d00; }
        .kpi-label { font-size: 8px; color: #555; font-weight: bold; text-transform: uppercase; letter-spacing: 1px; }
        .kpi-value { font-size: 11px; color: #aaa; font-weight: bold; }
        #viewport { width: 100%; height: 100vh; }
        .btn-icon { padding: 6px; border-radius: 4px; border: 1px solid #222; background: #0a0a0a; transition: all 0.2s; }
        .btn-icon:hover { border-color: #ff4d00; color: #ff4d00; }
        .badge { font-size: 7px; background: #ff4d00; color: white; padding: 1px 4px; border-radius: 3px; }
        .tab { padding: 4px 10px; border-radius: 6px; font-size: 9px; background: #0a0a0a; }
        .tab.active { background: #ff4d00; color: white; }
        .inspector-section { border-bottom: 1px solid rgba(255,77,0,0.1); padding-bottom: 12px; margin-bottom: 12px; }
        .grid-row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    </style>
</head>
<body class="flex">

    <!-- SPLASH/LOGIN -->
    <div id="login-screen" class="fixed inset-0 z-[200] flex items-center justify-center bg-black">
        <div class="ui-glass p-16 rounded-[50px] text-center border-orange-500/30 max-w-lg w-full mx-4 shadow-[0_0_100px_rgba(255,77,0,0.1)]">
            <div class="mb-8 text-7xl animate-pulse">üõ∞Ô∏è</div>
            <h1 class="text-6xl font-black mb-4 tracking-tighter italic"><span class="text-orange-500">MS</span>SOG</h1>
            <p class="text-zinc-600 text-[10px] mb-12 uppercase tracking-[0.5em]">Quantum Asset Intelligence Engine v6.0</p>
            <input type="password" id="password" placeholder="SECURITY KEY" class="input-dark text-center tracking-[1em] mb-6 p-5 text-lg">
            <button onclick="checkAccess()" class="w-full py-5 rounded-2xl bg-orange-600 hover:bg-orange-500 text-white font-bold transition-all shadow-lg shadow-orange-900/40">INITIALIZE CORE</button>
        </div>
    </div>

    <!-- MAIN UI -->
    <div id="editor-ui" class="hidden flex w-full h-full">
        
        <!-- LEFT: HIERARCHY & ASSETS -->
        <aside class="sidebar ui-glass border-r border-zinc-900 flex flex-col">
            <div class="p-4 border-b border-zinc-900 flex flex-col gap-3">
                <div class="flex justify-between items-center">
                    <h2 class="text-[10px] font-bold text-orange-500 uppercase tracking-[0.2em]">Scene Tree</h2>
                    <div class="flex gap-2">
                        <button onclick="addFolder()" class="btn-icon" title="New Folder">üìÅ</button>
                        <button onclick="exportScene()" class="btn-icon" title="Save Project">üíæ</button>
                        <button onclick="clearScene()" class="btn-icon" title="Reset Scene">üßπ</button>
                    </div>
                </div>
                <input type="text" id="tree-search" placeholder="Search objects..." class="input-dark" oninput="updateSceneTree()">
            </div>

            <div id="scene-tree" class="flex-1 overflow-y-auto"></div>

            <div class="p-4 border-t border-zinc-900 space-y-3">
                <p class="kpi-label">Construct</p>
                <div class="grid grid-cols-3 gap-1">
                    <button onclick="addPrimitive('cube')" class="py-2 bg-zinc-900 text-[9px] rounded hover:border-orange-500 border border-zinc-800">CUBE</button>
                    <button onclick="addPrimitive('sphere')" class="py-2 bg-zinc-900 text-[9px] rounded hover:border-orange-500 border border-zinc-800">SPHERE</button>
                    <button onclick="addPrimitive('plane')" class="py-2 bg-zinc-900 text-[9px] rounded hover:border-orange-500 border border-zinc-800">PLANE</button>
                </div>
                <div class="grid grid-cols-3 gap-1 mt-2">
                    <button onclick="addPrimitive('torus')" class="py-2 bg-zinc-900 text-[9px] rounded hover:border-orange-500 border border-zinc-800">TORUS</button>
                    <button onclick="addPrimitive('cylinder')" class="py-2 bg-zinc-900 text-[9px] rounded hover:border-orange-500 border border-zinc-800">CYL</button>
                    <button onclick="addPrimitive('cone')" class="py-2 bg-zinc-900 text-[9px] rounded hover:border-orange-500 border border-zinc-800">CONE</button>
                </div>
                <button onclick="document.getElementById('glb-input').click()" class="w-full py-3 bg-orange-600/10 text-orange-500 border border-orange-500/30 text-[9px] font-bold rounded-lg hover:bg-orange-600/20">UPLOAD GLB/GLTF</button>
                <input type="file" id="glb-input" class="hidden" accept=".glb,.gltf" onchange="handleGlbUpload()">
                
                <!-- 30 FITUR TAMBAHAN: BUTTONS -->
                <div class="pt-4 border-t border-zinc-800">
                    <p class="kpi-label mb-2">Quick Actions</p>
                    <div class="grid grid-cols-2 gap-1">
                        <button onclick="centerAllObjects()" class="py-2 bg-zinc-900/50 text-[8px] rounded hover:border-blue-500 border border-zinc-800">CENTER ALL</button>
                        <button onclick="randomizePositions()" class="py-2 bg-zinc-900/50 text-[8px] rounded hover:border-purple-500 border border-zinc-800">RANDOMIZE</button>
                        <button onclick="alignToGrid()" class="py-2 bg-zinc-900/50 text-[8px] rounded hover:border-green-500 border border-zinc-800">ALIGN GRID</button>
                        <button onclick="toggleWireframeAll()" class="py-2 bg-zinc-900/50 text-[8px] rounded hover:border-yellow-500 border border-zinc-800">WIRE ALL</button>
                        <button onclick="createLightProbe()" class="py-2 bg-zinc-900/50 text-[8px] rounded hover:border-cyan-500 border border-zinc-800">LIGHT PROBE</button>
                        <button onclick="bakeSceneLighting()" class="py-2 bg-zinc-900/50 text-[8px] rounded hover:border-pink-500 border border-zinc-800">BAKE LIGHT</button>
                        <button onclick="generateTerrain()" class="py-2 bg-zinc-900/50 text-[8px] rounded hover:border-emerald-500 border border-zinc-800">TERRAIN</button>
                        <button onclick="createParticles()" class="py-2 bg-zinc-900/50 text-[8px] rounded hover:border-rose-500 border border-zinc-800">PARTICLES</button>
                    </div>
                </div>
            </div>
        </aside>

        <!-- CENTER: VIEWPORT -->
        <main class="flex-1 relative flex flex-col">
            <!-- TOOLBAR -->
            <div class="absolute top-6 left-1/2 -translate-x-1/2 z-[60] flex items-center gap-1 ui-glass p-2 rounded-2xl shadow-2xl border-zinc-800">
                <div class="flex gap-1 px-2 border-r border-zinc-800">
                    <button id="tool-translate" onclick="setToolMode('translate')" class="px-4 py-2 rounded-xl text-[10px] active-tool">G</button>
                    <button id="tool-rotate" onclick="setToolMode('rotate')" class="px-4 py-2 rounded-xl text-[10px] hover:bg-zinc-900">R</button>
                    <button id="tool-scale" onclick="setToolMode('scale')" class="px-4 py-2 rounded-xl text-[10px] hover:bg-zinc-900">S</button>
                </div>
                <div class="flex gap-1 px-2">
                    <button id="snap-btn" onclick="toggleSnap()" class="px-3 py-2 rounded-xl text-[9px] hover:bg-zinc-900">SNAP: OFF</button>
                    <button onclick="undo()" class="p-2 hover:text-orange-400">‚Ü©</button>
                    <button onclick="redo()" class="p-2 hover:text-orange-400">‚Ü™</button>
                    <button onclick="duplicateObject()" class="px-3 py-2 rounded-xl text-[9px] hover:bg-zinc-900">CLONE</button>
                </div>
                <div class="flex gap-1 px-2 border-l border-zinc-800">
                    <button onclick="toggleSymmetry()" class="px-3 py-2 rounded-xl text-[9px] hover:bg-zinc-900">SYM: OFF</button>
                    <button onclick="togglePhysics()" class="px-3 py-2 rounded-xl text-[9px] hover:bg-zinc-900">PHYSICS</button>
                    <button onclick="toggleXR()" class="px-3 py-2 rounded-xl text-[9px] hover:bg-zinc-900">XR MODE</button>
                </div>
            </div>

            <div id="viewport"></div>

            <!-- FOOTER KPI -->
            <div class="absolute bottom-6 left-6 z-50 pointer-events-none flex gap-8">
                <div><p class="kpi-label">Performance</p><p class="kpi-value" id="fps-val">60 FPS</p></div>
                <div><p class="kpi-label">Poly Count</p><p class="kpi-value" id="poly-val">0 Tris</p></div>
                <div><p class="kpi-label">Entities</p><p class="kpi-value" id="obj-val">0</p></div>
                <div><p class="kpi-label">VRAM</p><p class="kpi-value" id="vram-val">0 MB</p></div>
                <div><p class="kpi-label">Engine</p><p class="kpi-value text-orange-500">MSSOG v6.0 ULTRA</p></div>
            </div>

            <!-- WORLD SETTINGS SHORTCUT -->
            <div class="absolute top-6 right-6 z-50 flex flex-col gap-2 ui-glass p-3 rounded-2xl">
                <select id="sky-select" onchange="updateWorld()" class="input-dark text-[9px]">
                    <option value="0x020202">VOID DARK</option>
                    <option value="0x111122">DEEP SEA</option>
                    <option value="0x221111">MARS RED</option>
                    <option value="0x222222">STUDIO</option>
                    <option value="0x112233">CYBER BLUE</option>
                </select>
                <button onclick="toggleGrid()" id="grid-btn" class="text-[9px] py-1 bg-zinc-900 rounded border border-zinc-800">GRID: ON</button>
                <button onclick="screenshot()" class="text-[9px] py-1 bg-orange-600/20 text-orange-400 rounded border border-orange-500/20">CAPTURE</button>
                <button onclick="togglePostFX()" id="postfx-btn" class="text-[9px] py-1 bg-purple-600/20 text-purple-400 rounded border border-purple-500/20">POSTFX: ON</button>
            </div>

            <!-- BOTTOM RIGHT: MINI MAP -->
            <div id="minimap" class="absolute bottom-6 right-6 z-40 w-32 h-32 bg-black/50 rounded-lg border border-zinc-800 overflow-hidden">
                <canvas id="minimap-canvas"></canvas>
            </div>
        </main>

        <!-- RIGHT: INSPECTOR -->
        <aside class="sidebar ui-glass border-l border-zinc-900 flex flex-col p-4 space-y-4 overflow-y-auto">
            <div class="flex gap-1 mb-4">
                <button onclick="switchTab('transform')" class="tab active">TRANSFORM</button>
                <button onclick="switchTab('material')" class="tab">MATERIAL</button>
                <button onclick="switchTab('physics')" class="tab">PHYSICS</button>
                <button onclick="switchTab('script')" class="tab">SCRIPT</button>
            </div>
            
            <div id="inspector-transform" class="space-y-4">
                <!-- Transform content will be loaded here -->
            </div>
            
            <div id="inspector-material" class="space-y-4 hidden">
                <!-- Material content will be loaded here -->
            </div>
            
            <div id="inspector-physics" class="space-y-4 hidden">
                <!-- Physics content will be loaded here -->
            </div>
            
            <div id="inspector-script" class="space-y-4 hidden">
                <!-- Script content will be loaded here -->
            </div>
        </aside>
    </div>

    <script>
        // SHADER DEFINITIONS (karena CDN tidak menyertakan shader yang diperlukan)
        const CopyShader = {
            uniforms: {
                tDiffuse: { value: null },
                opacity: { value: 1.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }
            `,
            fragmentShader: `
                uniform float opacity;
                uniform sampler2D tDiffuse;
                varying vec2 vUv;
                void main() {
                    vec4 texel = texture2D( tDiffuse, vUv );
                    gl_FragColor = opacity * texel;
                }
            `
        };

        const LuminosityHighPassShader = {
            uniforms: {
                tDiffuse: { value: null },
                luminosityThreshold: { value: 1.0 },
                smoothWidth: { value: 1.0 },
                defaultColor: { value: new THREE.Color(0x000000) },
                defaultOpacity: { value: 0.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform vec3 defaultColor;
                uniform float defaultOpacity;
                uniform float luminosityThreshold;
                uniform float smoothWidth;
                varying vec2 vUv;
                void main() {
                    vec4 texel = texture2D( tDiffuse, vUv );
                    vec3 luma = vec3( 0.299, 0.587, 0.114 );
                    float v = dot( texel.xyz, luma );
                    vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );
                    float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );
                    gl_FragColor = mix( outputColor, texel, alpha );
                }
            `
        };

        const ACCESS_PASS = "ssog123";
        let scene, camera, renderer, orbit, transformControl, raycaster, mouse, gridHelper, selectionBox, clock;
        let selectedObject = null;
        let mainGroup = new THREE.Group();
        let history = [], historyStep = -1;
        let snapEnabled = false;
        let isGridVisible = true;
        let symmetryEnabled = false;
        let physicsEnabled = false;
        let postFXEnabled = false; // Disable postFX dulu untuk menghindari error
        let minimapCamera, minimapRenderer;

        // --- 30 FITUR UMUM TAMBAHAN ---
        const FEATURES = {
            autoSave: false,
            sceneVersioning: true,
            multiSelect: false,
            layerSystem: [],
            flyMode: false,
            walkMode: false,
            cameraPaths: [],
            measuringTool: false,
            protractorTool: false,
            rulerTool: false,
            exportFormats: ['GLB', 'GLTF', 'OBJ', 'FBX', 'STL', 'USDZ'],
            autoUV: false,
            autoLOD: false,
            autoLighting: false,
            realtimeCollab: false,
            versionControl: false,
            commentSystem: false,
            realtimeGI: false,
            raytracing: false,
            pathTracing: false,
            timelineEditor: false,
            keyframeAnimation: false,
            morphTargets: false,
            clothSim: false,
            fluidSim: false,
            softBody: false,
            arPreview: false,
            vrPreview: false,
            webXR: false
        };

        // --- AUTH ---
        function checkAccess() {
            if (document.getElementById('password').value === ACCESS_PASS) {
                document.getElementById('login-screen').style.display = 'none';
                document.getElementById('editor-ui').classList.remove('hidden');
                initEngine();
            }
        }

        // --- CORE ENGINE ---
        function initEngine() {
            const container = document.getElementById('viewport');
            clock = new THREE.Clock();
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020202);
            scene.fog = new THREE.Fog(0x020202, 100, 500);
            scene.add(mainGroup);

            camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 5000);
            camera.position.set(20, 20, 20);

            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                preserveDrawingBuffer: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1;
            container.appendChild(renderer.domElement);

            // Grid
            gridHelper = new THREE.GridHelper(100, 50, 0xff4d00, 0x111111);
            gridHelper.material.transparent = true;
            gridHelper.material.opacity = 0.2;
            scene.add(gridHelper);

            // Orbit Controls
            orbit = new THREE.OrbitControls(camera, renderer.domElement);
            orbit.enableDamping = true;
            orbit.dampingFactor = 0.05;
            orbit.maxDistance = 1000;
            orbit.minDistance = 1;

            // Transform Control
            transformControl = new THREE.TransformControls(camera, renderer.domElement);
            transformControl.addEventListener('dragging-changed', (e) => {
                orbit.enabled = !e.value;
                if (!e.value) { 
                    saveHistory(); 
                    updateInspector();
                    if (symmetryEnabled) applySymmetry();
                }
            });
            transformControl.addEventListener('change', () => {
                if (selectionBox.visible && selectedObject) {
                    selectionBox.setFromObject(selectedObject);
                }
            });
            scene.add(transformControl);

            // Selection Box
            selectionBox = new THREE.BoxHelper();
            selectionBox.material.color.set(0xff4d00);
            selectionBox.visible = false;
            scene.add(selectionBox);

            // Lights
            scene.add(new THREE.AmbientLight(0xffffff, 0.3));
            
            const sun = new THREE.DirectionalLight(0xffffff, 1);
            sun.position.set(50, 100, 50);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            sun.shadow.camera.near = 0.5;
            sun.shadow.camera.far = 500;
            scene.add(sun);

            // Fill Light
            const fillLight = new THREE.PointLight(0xffaa33, 0.5, 100);
            fillLight.position.set(-20, 20, -20);
            scene.add(fillLight);

            // Raycaster
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Minimap
            initMinimap();

            // Event Listeners
            renderer.domElement.addEventListener('mousedown', onSelect);
            window.addEventListener('resize', onResize);
            document.addEventListener('keydown', onKey);
            document.addEventListener('visibilitychange', autoSaveCheck);

            // Initial Scene
            createDefaultScene();
            animate();
            saveHistory();
        }

        function initMinimap() {
            const canvas = document.getElementById('minimap-canvas');
            minimapRenderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                antialias: false,
                alpha: true 
            });
            minimapRenderer.setSize(128, 128);
            minimapRenderer.setClearColor(0x000000, 0);
            
            minimapCamera = new THREE.OrthographicCamera(-50, 50, 50, -50, 1, 1000);
            minimapCamera.position.set(0, 100, 0);
            minimapCamera.lookAt(0, 0, 0);
        }

        function createDefaultScene() {
            // Add a ground plane
            const groundGeo = new THREE.PlaneGeometry(100, 100);
            const groundMat = new THREE.MeshStandardMaterial({ 
                color: 0x222222, 
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            ground.name = "Ground_Plane";
            mainGroup.add(ground);

            // Add some starter objects
            for(let i = 0; i < 3; i++) {
                const geo = new THREE.BoxGeometry(2, 2, 2);
                const mat = new THREE.MeshStandardMaterial({ 
                    color: Math.random() * 0xffffff,
                    metalness: Math.random(),
                    roughness: Math.random()
                });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(
                    (Math.random() - 0.5) * 20,
                    Math.random() * 5,
                    (Math.random() - 0.5) * 20
                );
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.name = `Object_${i}`;
                mainGroup.add(mesh);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            
            // Update orbit controls
            orbit.update();
            
            // Update selection box
            if (selectionBox.visible && selectedObject) {
                selectionBox.setFromObject(selectedObject);
            }
            
            // Update minimap
            updateMinimap();
            
            // Render
            renderer.render(scene, camera);
            
            // Update KPI stats
            updateStats();
        }

        function updateStats() {
            const fps = Math.round(1 / clock.getDelta());
            document.getElementById('fps-val').innerText = `${fps} FPS`;
            
            // Poly count
            let tris = 0;
            let objs = 0;
            mainGroup.traverse((node) => {
                if (node.isMesh) {
                    if (node.geometry.index) {
                        tris += node.geometry.index.count / 3;
                    } else {
                        tris += node.geometry.attributes.position.count / 3;
                    }
                    objs++;
                }
            });
            document.getElementById('poly-val').innerText = `${Math.round(tris).toLocaleString()} Tris`;
            document.getElementById('obj-val').innerText = `${objs}`;
            
            // VRAM estimation
            const vram = Math.round((tris * 100) / 1000000);
            document.getElementById('vram-val').innerText = `${vram} MB`;
        }

        function updateMinimap() {
            minimapCamera.position.x = camera.position.x;
            minimapCamera.position.z = camera.position.z;
            minimapRenderer.render(scene, minimapCamera);
        }

        // --- 30 FITUR UMUM IMPLEMENTASI ---
        function centerAllObjects() {
            const bbox = new THREE.Box3();
            mainGroup.children.forEach(child => {
                if (child !== gridHelper) {
                    bbox.expandByObject(child);
                }
            });
            
            const center = bbox.getCenter(new THREE.Vector3());
            mainGroup.position.sub(center);
            saveHistory();
        }

        function randomizePositions() {
            mainGroup.children.forEach(child => {
                if (child !== gridHelper && !child.userData?.isFolder) {
                    child.position.set(
                        (Math.random() - 0.5) * 40,
                        Math.random() * 20,
                        (Math.random() - 0.5) * 40
                    );
                }
            });
            saveHistory();
        }

        function alignToGrid() {
            mainGroup.children.forEach(child => {
                if (child.isMesh) {
                    child.position.x = Math.round(child.position.x);
                    child.position.y = Math.round(child.position.y);
                    child.position.z = Math.round(child.position.z);
                }
            });
            saveHistory();
        }

        function toggleWireframeAll() {
            mainGroup.traverse(node => {
                if (node.isMesh) {
                    node.material.wireframe = !node.material.wireframe;
                }
            });
        }

        function createLightProbe() {
            const probe = new THREE.LightProbe();
            probe.name = "Light_Probe";
            mainGroup.add(probe);
            updateSceneTree();
            saveHistory();
        }

        function bakeSceneLighting() {
            alert("Light baking started... This feature requires additional setup with a baking engine.");
        }

        function generateTerrain() {
            const size = 100;
            const segments = 100;
            const geometry = new THREE.PlaneGeometry(size, size, segments, segments);
            
            const vertices = geometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                vertices[i + 2] = Math.random() * 10;
            }
            geometry.computeVertexNormals();
            
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x558855,
                roughness: 0.8,
                metalness: 0.1
            });
            
            const terrain = new THREE.Mesh(geometry, material);
            terrain.rotation.x = -Math.PI / 2;
            terrain.receiveShadow = true;
            terrain.castShadow = true;
            terrain.name = "Procedural_Terrain";
            mainGroup.add(terrain);
            
            saveHistory();
            updateSceneTree();
        }

        function createParticles() {
            const particleCount = 1000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 100;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 100;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
                
                colors[i * 3] = Math.random();
                colors[i * 3 + 1] = Math.random();
                colors[i * 3 + 2] = Math.random();
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.5,
                vertexColors: true,
                transparent: true,
                opacity: 0.8
            });
            
            const particles = new THREE.Points(geometry, material);
            particles.name = "Particle_System";
            mainGroup.add(particles);
            
            saveHistory();
            updateSceneTree();
        }

        function toggleSymmetry() {
            symmetryEnabled = !symmetryEnabled;
            alert(`Symmetry ${symmetryEnabled ? 'Enabled' : 'Disabled'}`);
        }

        function togglePhysics() {
            physicsEnabled = !physicsEnabled;
            alert(`Physics ${physicsEnabled ? 'Enabled' : 'Disabled'}`);
        }

        function toggleXR() {
            alert("XR Mode would require WebXR API implementation");
        }

        function togglePostFX() {
            postFXEnabled = !postFXEnabled;
            document.getElementById('postfx-btn').innerText = `POSTFX: ${postFXEnabled ? 'ON' : 'OFF'}`;
            alert("PostFX requires additional shader setup");
        }

        function applySymmetry() {
            if (!selectedObject || !symmetryEnabled || !selectedObject.isMesh) return;
            
            const clone = selectedObject.clone();
            clone.position.x = -selectedObject.position.x;
            clone.scale.x = -Math.abs(selectedObject.scale.x);
            
            if (clone.material) {
                clone.material = selectedObject.material.clone();
            }
            
            mainGroup.add(clone);
            clone.name = selectedObject.name + "_SYM";
            
            saveHistory();
            updateSceneTree();
        }

        function autoSaveCheck() {
            if (FEATURES.autoSave && document.hidden) {
                autoSave();
            }
        }

        function autoSave() {
            try {
                localStorage.setItem('mssog_autosave', JSON.stringify(mainGroup.toJSON()));
                console.log("Auto-saved scene");
            } catch (e) {
                console.warn("Could not auto-save:", e);
            }
        }

        // --- HIERARCHY & ASSETS ---
        function updateSceneTree() {
            const tree = document.getElementById('scene-tree');
            const search = document.getElementById('tree-search').value.toLowerCase();
            tree.innerHTML = "";

            const renderNode = (node, depth = 0) => {
                if (!node || node === transformControl || node === selectionBox) return;
                
                if (node.name && node.name.toLowerCase().indexOf(search) === -1 && search !== "") return;
                
                const item = document.createElement('div');
                item.className = `tree-item ${selectedObject === node ? 'selected' : ''}`;
                item.style.paddingLeft = `${depth * 16 + 12}px`;
                
                const isFolder = node.userData?.isFolder;
                const icon = isFolder ? 'üìÅ' : 
                            node.isLight ? 'üí°' :
                            node.isCamera ? 'üì∑' :
                            node.isMesh ? 'üßä' : '‚öôÔ∏è';
                
                item.innerHTML = `
                    <span>${icon}</span>
                    <span class="flex-1 truncate">${node.name || 'Unnamed'}</span>
                    ${node.visible ? '' : '<span class="text-[8px] opacity-40">HIDDEN</span>'}
                    ${node.children?.length > 0 ? `<span class="text-[8px] opacity-40">${node.children.length}</span>` : ''}
                `;
                
                item.onclick = (e) => { 
                    e.stopPropagation(); 
                    selectObject(node); 
                };
                tree.appendChild(item);

                if (node.children && node.children.length > 0) {
                    node.children.forEach(c => {
                        renderNode(c, depth + 1);
                    });
                }
            };

            mainGroup.children.forEach(c => {
                if (c !== transformControl && c !== selectionBox) {
                    renderNode(c);
                }
            });
        }

        function selectObject(obj) {
            // Detach dari objek sebelumnya
            if (transformControl.attach && typeof transformControl.attach === 'function') {
                transformControl.detach();
            }
            
            selectedObject = obj;
            
            if (obj && !obj.userData?.isFolder) {
                if (transformControl.attach && typeof transformControl.attach === 'function') {
                    transformControl.attach(obj);
                }
                selectionBox.setFromObject(obj);
                selectionBox.visible = true;
            } else {
                if (transformControl.detach && typeof transformControl.detach === 'function') {
                    transformControl.detach();
                }
                selectionBox.visible = false;
            }
            
            updateSceneTree();
            updateInspector();
        }

        // --- PRIMITIVES ---
        function addPrimitive(type) {
            let geo;
            switch(type) {
                case 'cube':
                    geo = new THREE.BoxGeometry(2, 2, 2);
                    break;
                case 'sphere':
                    geo = new THREE.SphereGeometry(1.5, 32, 32);
                    break;
                case 'plane':
                    geo = new THREE.PlaneGeometry(10, 10);
                    break;
                case 'cylinder':
                    geo = new THREE.CylinderGeometry(1, 1, 3, 32);
                    break;
                case 'cone':
                    geo = new THREE.ConeGeometry(1.5, 3, 32);
                    break;
                case 'torus':
                    geo = new THREE.TorusGeometry(1.5, 0.5, 16, 100);
                    break;
                case 'torusknot':
                    geo = new THREE.TorusKnotGeometry(1.5, 0.5, 100, 16);
                    break;
                case 'octahedron':
                    geo = new THREE.OctahedronGeometry(1.5);
                    break;
                case 'dodecahedron':
                    geo = new THREE.DodecahedronGeometry(1.5);
                    break;
                case 'icosahedron':
                    geo = new THREE.IcosahedronGeometry(1.5);
                    break;
                default:
                    geo = new THREE.BoxGeometry(2, 2, 2);
            }

            const mat = new THREE.MeshStandardMaterial({ 
                color: 0x888888, 
                metalness: 0.2, 
                roughness: 0.8,
                side: THREE.DoubleSide
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.name = type.toUpperCase() + "_" + Math.floor(Math.random() * 1000);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            // Random position near center
            mesh.position.set(
                (Math.random() - 0.5) * 10,
                Math.random() * 5,
                (Math.random() - 0.5) * 10
            );
            
            mainGroup.add(mesh);
            selectObject(mesh);
            saveHistory();
        }

        function addFolder() {
            const g = new THREE.Group();
            g.name = "FOLDER_" + Math.floor(Math.random() * 100);
            g.userData = { isFolder: true };
            mainGroup.add(g);
            updateSceneTree();
            saveHistory();
        }

        function handleGlbUpload() {
            const f = document.getElementById('glb-input').files[0];
            if (!f) return;
            
            const loader = new THREE.GLTFLoader();
            loader.load(URL.createObjectURL(f), (gltf) => {
                const model = gltf.scene;
                model.name = f.name.split('.')[0];
                
                // Enable shadows for all meshes
                model.traverse(node => {
                    if (node.isMesh) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                    }
                });
                
                mainGroup.add(model);
                updateSceneTree();
                saveHistory();
            }, undefined, (error) => {
                console.error("Error loading GLB:", error);
                alert("Error loading model. Please check console for details.");
            });
        }

        // --- INSPECTOR ---
        function switchTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('[id^="inspector-"]').forEach(el => {
                el.classList.add('hidden');
            });
            // Remove active class from all tabs
            document.querySelectorAll('.tab').forEach(t => {
                t.classList.remove('active');
            });
            // Show selected tab
            const tabElement = document.getElementById(`inspector-${tabName}`);
            if (tabElement) {
                tabElement.classList.remove('hidden');
            }
            // Set active tab
            event.target.classList.add('active');
            
            // Update content if needed
            if (tabName === 'material') {
                updateMaterialTab();
            }
        }

        function updateInspector() {
            if (!selectedObject) {
                document.getElementById('inspector-transform').innerHTML = 
                    `<div class="text-center py-20 text-zinc-800 text-[10px] italic">Select an entity</div>`;
                return;
            }

            updateTransformTab();
        }

        function updateTransformTab() {
            const isMesh = selectedObject.isMesh;
            const panel = document.getElementById('inspector-transform');
            
            panel.innerHTML = `
                <div class="space-y-4">
                    <section class="inspector-section">
                        <label class="kpi-label">Entity Properties</label>
                        <input type="text" value="${selectedObject.name || ''}" onchange="editProp('name', this.value)" class="input-dark mb-2">
                        
                        <div class="grid-row">
                            <div>
                                <p class="text-[7px] text-zinc-600">Visible</p>
                                <input type="checkbox" ${selectedObject.visible ? 'checked' : ''} onchange="editProp('visible', this.checked)" class="mt-1">
                            </div>
                            <div>
                                <p class="text-[7px] text-zinc-600">Cast Shadow</p>
                                <input type="checkbox" ${selectedObject.castShadow ? 'checked' : ''} onchange="editProp('castShadow', this.checked)" class="mt-1">
                            </div>
                        </div>
                    </section>

                    <section class="inspector-section">
                        <label class="kpi-label">Transform</label>
                        <div class="grid grid-cols-3 gap-2 mb-2">
                            <div><p class="text-[7px] text-zinc-600 mb-1">POS X</p><input type="number" step="0.1" value="${selectedObject.position.x.toFixed(2)}" onchange="editProp('px', this.value)" class="input-dark"></div>
                            <div><p class="text-[7px] text-zinc-600 mb-1">POS Y</p><input type="number" step="0.1" value="${selectedObject.position.y.toFixed(2)}" onchange="editProp('py', this.value)" class="input-dark"></div>
                            <div><p class="text-[7px] text-zinc-600 mb-1">POS Z</p><input type="number" step="0.1" value="${selectedObject.position.z.toFixed(2)}" onchange="editProp('pz', this.value)" class="input-dark"></div>
                        </div>
                        
                        <div class="grid grid-cols-3 gap-2 mb-2">
                            <div><p class="text-[7px] text-zinc-600 mb-1">ROT X</p><input type="number" step="0.1" value="${THREE.MathUtils.radToDeg(selectedObject.rotation.x).toFixed(1)}" onchange="editProp('rx', this.value)" class="input-dark"></div>
                            <div><p class="text-[7px] text-zinc-600 mb-1">ROT Y</p><input type="number" step="0.1" value="${THREE.MathUtils.radToDeg(selectedObject.rotation.y).toFixed(1)}" onchange="editProp('ry', this.value)" class="input-dark"></div>
                            <div><p class="text-[7px] text-zinc-600 mb-1">ROT Z</p><input type="number" step="0.1" value="${THREE.MathUtils.radToDeg(selectedObject.rotation.z).toFixed(1)}" onchange="editProp('rz', this.value)" class="input-dark"></div>
                        </div>
                        
                        <div class="grid grid-cols-3 gap-2">
                            <div><p class="text-[7px] text-zinc-600 mb-1">SCALE X</p><input type="number" step="0.1" value="${selectedObject.scale.x.toFixed(2)}" onchange="editProp('sx', this.value)" class="input-dark"></div>
                            <div><p class="text-[7px] text-zinc-600 mb-1">SCALE Y</p><input type="number" step="0.1" value="${selectedObject.scale.y.toFixed(2)}" onchange="editProp('sy', this.value)" class="input-dark"></div>
                            <div><p class="text-[7px] text-zinc-600 mb-1">SCALE Z</p><input type="number" step="0.1" value="${selectedObject.scale.z.toFixed(2)}" onchange="editProp('sz', this.value)" class="input-dark"></div>
                        </div>
                    </section>

                    ${isMesh ? `
                    <section class="inspector-section">
                        <label class="kpi-label">Geometry</label>
                        <div class="grid-row">
                            <div>
                                <p class="text-[7px] text-zinc-600">Wireframe</p>
                                <input type="checkbox" ${selectedObject.material.wireframe ? 'checked' : ''} onchange="editProp('wire', this.checked)" class="mt-1">
                            </div>
                            <div>
                                <p class="text-[7px] text-zinc-600">Double Side</p>
                                <input type="checkbox" ${selectedObject.material.side === THREE.DoubleSide ? 'checked' : ''} onchange="editProp('doubleSide', this.checked)" class="mt-1">
                            </div>
                        </div>
                    </section>
                    ` : ''}

                    <section>
                        <button onclick="deleteObject()" class="w-full py-3 bg-red-950/20 text-red-500 border border-red-950/30 text-[9px] font-bold rounded-xl hover:bg-red-600 hover:text-white transition-all">DELETE ENTITY</button>
                    </section>
                </div>
            `;
        }

        function updateMaterialTab() {
            if (!selectedObject || !selectedObject.isMesh) {
                document.getElementById('inspector-material').innerHTML = 
                    `<div class="text-center py-20 text-zinc-800 text-[10px] italic">Select a mesh to edit material</div>`;
                return;
            }

            const mat = selectedObject.material;
            const panel = document.getElementById('inspector-material');
            
            panel.innerHTML = `
                <div class="space-y-4">
                    <section class="inspector-section">
                        <label class="kpi-label">Material Presets</label>
                        <div class="grid grid-cols-3 gap-1">
                            <button onclick="applyMaterialPreset('glass')" class="py-2 bg-zinc-900 text-[8px] rounded hover:border-blue-500 border border-zinc-800">GLASS</button>
                            <button onclick="applyMaterialPreset('metal')" class="py-2 bg-zinc-900 text-[8px] rounded hover:border-gray-500 border border-zinc-800">METAL</button>
                            <button onclick="applyMaterialPreset('plastic')" class="py-2 bg-zinc-900 text-[8px] rounded hover:border-white border border-zinc-800">PLASTIC</button>
                            <button onclick="applyMaterialPreset('rubber')" class="py-2 bg-zinc-900 text-[8px] rounded hover:border-black border border-zinc-800">RUBBER</button>
                            <button onclick="applyMaterialPreset('water')" class="py-2 bg-zinc-900 text-[8px] rounded hover:border-cyan-500 border border-zinc-800">WATER</button>
                            <button onclick="applyMaterialPreset('emissive')" class="py-2 bg-zinc-900 text-[8px] rounded hover:border-yellow-500 border border-zinc-800">EMISSIVE</button>
                            <button onclick="applyMaterialPreset('hologram')" class="py-2 bg-zinc-900 text-[8px] rounded hover:border-green-500 border border-zinc-800">HOLOGRAM</button>
                            <button onclick="applyMaterialPreset('neon')" class="py-2 bg-zinc-900 text-[8px] rounded hover:border-pink-500 border border-zinc-800">NEON</button>
                            <button onclick="applyMaterialPreset('lava')" class="py-2 bg-zinc-900 text-[8px] rounded hover:border-red-500 border border-zinc-800">LAVA</button>
                        </div>
                    </section>

                    <section class="inspector-section">
                        <label class="kpi-label">Base Color</label>
                        <div class="flex items-center gap-3 mb-3">
                            <input type="color" value="#${mat.color.getHexString()}" onchange="editProp('color', this.value)" class="w-10 h-10 bg-transparent border-none cursor-pointer">
                            <div class="flex-1">
                                <p class="text-[8px] text-zinc-500">HEX: #${mat.color.getHexString().toUpperCase()}</p>
                                <p class="text-[8px] text-zinc-700">RGB: ${mat.color.r.toFixed(2)}, ${mat.color.g.toFixed(2)}, ${mat.color.b.toFixed(2)}</p>
                            </div>
                        </div>
                    </section>

                    <section class="inspector-section">
                        <label class="kpi-label">PBR Properties</label>
                        <div class="space-y-3">
                            <div>
                                <p class="text-[7px] text-zinc-600 mb-1">Metalness: ${mat.metalness?.toFixed(2) || '0.00'}</p>
                                <input type="range" min="0" max="1" step="0.01" value="${mat.metalness || 0}" oninput="editProp('metal', this.value)" class="w-full">
                            </div>
                            <div>
                                <p class="text-[7px] text-zinc-600 mb-1">Roughness: ${mat.roughness?.toFixed(2) || '0.50'}</p>
                                <input type="range" min="0" max="1" step="0.01" value="${mat.roughness || 0.5}" oninput="editProp('rough', this.value)" class="w-full">
                            </div>
                        </div>
                    </section>

                    <section>
                        <button onclick="deleteObject()" class="w-full py-3 bg-red-950/20 text-red-500 border border-red-950/30 text-[9px] font-bold rounded-xl hover:bg-red-600 hover:text-white transition-all">DELETE ENTITY</button>
                    </section>
                </div>
            `;
        }

        function editProp(prop, val) {
            if (!selectedObject) return;
            
            try {
                switch(prop) {
                    case 'name':
                        selectedObject.name = val;
                        break;
                    case 'px':
                        selectedObject.position.x = parseFloat(val);
                        break;
                    case 'py':
                        selectedObject.position.y = parseFloat(val);
                        break;
                    case 'pz':
                        selectedObject.position.z = parseFloat(val);
                        break;
                    case 'rx':
                        selectedObject.rotation.x = THREE.MathUtils.degToRad(parseFloat(val));
                        break;
                    case 'ry':
                        selectedObject.rotation.y = THREE.MathUtils.degToRad(parseFloat(val));
                        break;
                    case 'rz':
                        selectedObject.rotation.z = THREE.MathUtils.degToRad(parseFloat(val));
                        break;
                    case 'sx':
                        selectedObject.scale.x = parseFloat(val);
                        break;
                    case 'sy':
                        selectedObject.scale.y = parseFloat(val);
                        break;
                    case 'sz':
                        selectedObject.scale.z = parseFloat(val);
                        break;
                    case 'visible':
                        selectedObject.visible = val;
                        break;
                    case 'castShadow':
                        selectedObject.castShadow = val;
                        break;
                    case 'wire':
                        if (selectedObject.isMesh && selectedObject.material) {
                            selectedObject.material.wireframe = val;
                        }
                        break;
                    case 'doubleSide':
                        if (selectedObject.isMesh && selectedObject.material) {
                            selectedObject.material.side = val ? THREE.DoubleSide : THREE.FrontSide;
                        }
                        break;
                    case 'color':
                        if (selectedObject.isMesh && selectedObject.material) {
                            selectedObject.material.color.set(val);
                        }
                        break;
                    case 'metal':
                        if (selectedObject.isMesh && selectedObject.material) {
                            selectedObject.material.metalness = parseFloat(val);
                        }
                        break;
                    case 'rough':
                        if (selectedObject.isMesh && selectedObject.material) {
                            selectedObject.material.roughness = parseFloat(val);
                        }
                        break;
                    case 'emissive':
                        if (selectedObject.isMesh && selectedObject.material) {
                            selectedObject.material.emissive.set(val);
                        }
                        break;
                    case 'emissiveIntensity':
                        if (selectedObject.isMesh && selectedObject.material) {
                            selectedObject.material.emissiveIntensity = parseFloat(val);
                        }
                        break;
                    case 'opacity':
                        if (selectedObject.isMesh && selectedObject.material) {
                            selectedObject.material.opacity = parseFloat(val);
                            selectedObject.material.transparent = val < 1;
                        }
                        break;
                    case 'transmission':
                        if (selectedObject.isMesh && selectedObject.material) {
                            selectedObject.material.transmission = parseFloat(val);
                        }
                        break;
                }

                if (selectedObject.isMesh && selectedObject.material) {
                    selectedObject.material.needsUpdate = true;
                }
                
                updateSceneTree();
                updateInspector();
                saveHistory();
            } catch (error) {
                console.error("Error editing property:", error);
            }
        }

        // --- 30 FITUR MATERIAL IMPLEMENTASI ---
        function applyMaterialPreset(preset) {
            if (!selectedObject || !selectedObject.isMesh || !selectedObject.material) return;
            
            const mat = selectedObject.material;
            
            try {
                switch(preset) {
                    case 'glass':
                        mat.transparent = true;
                        mat.opacity = 0.3;
                        mat.roughness = 0;
                        mat.metalness = 0;
                        mat.color.set(0xffffff);
                        break;
                        
                    case 'water':
                        mat.color.set(0x0088ff);
                        mat.transparent = true;
                        mat.opacity = 0.5;
                        mat.roughness = 0.1;
                        mat.metalness = 0.8;
                        break;
                        
                    case 'metal':
                        mat.roughness = 0.2;
                        mat.metalness = 1;
                        mat.color.set(0x888888);
                        break;
                        
                    case 'plastic':
                        mat.roughness = 0.8;
                        mat.metalness = 0;
                        mat.color.set(0xff4444);
                        break;
                        
                    case 'rubber':
                        mat.roughness = 1;
                        mat.metalness = 0;
                        mat.color.set(0x333333);
                        break;
                        
                    case 'emissive':
                        mat.emissive.set(mat.color);
                        mat.emissiveIntensity = 2;
                        break;
                        
                    case 'hologram':
                        mat.transparent = true;
                        mat.opacity = 0.3;
                        mat.emissive.set(0x00ff00);
                        mat.emissiveIntensity = 3;
                        mat.wireframe = true;
                        break;
                        
                    case 'neon':
                        mat.emissive.set(0xff00ff);
                        mat.emissiveIntensity = 5;
                        mat.roughness = 0.1;
                        mat.color.set(0xff00ff);
                        break;
                        
                    case 'carbon_fiber':
                        mat.roughness = 0.3;
                        mat.metalness = 0.8;
                        mat.color.set(0x222222);
                        break;
                        
                    case 'lava':
                        mat.emissive.set(0xff3300);
                        mat.emissiveIntensity = 3;
                        mat.roughness = 0.8;
                        mat.color.set(0xff5500);
                        break;
                }
                
                mat.needsUpdate = true;
                updateInspector();
                saveHistory();
            } catch (error) {
                console.error("Error applying material preset:", error);
            }
        }

        function generateProceduralMaterial() {
            if (!selectedObject || !selectedObject.isMesh) return;
            
            try {
                const mat = selectedObject.material;
                
                // Create a procedural pattern
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 512;
                const ctx = canvas.getContext('2d');
                
                // Generate noise/pattern
                for(let x = 0; x < 512; x += 4) {
                    for(let y = 0; y < 512; y += 4) {
                        const value = Math.random() * 255;
                        ctx.fillStyle = `rgb(${value},${value},${value})`;
                        ctx.fillRect(x, y, 4, 4);
                    }
                }
                
                const texture = new THREE.CanvasTexture(canvas);
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(4, 4);
                
                mat.map = texture;
                mat.needsUpdate = true;
                
                saveHistory();
                updateInspector();
            } catch (error) {
                console.error("Error generating procedural material:", error);
            }
        }

        // --- ACTIONS & TOOLS ---
        function deleteObject() {
            if (!selectedObject || selectedObject === gridHelper || selectedObject === transformControl || selectedObject === selectionBox) return;
            
            if (confirm(`Delete "${selectedObject.name || 'selected object'}"?`)) {
                try {
                    const obj = selectedObject;
                    
                    if (transformControl && typeof transformControl.detach === 'function') {
                        transformControl.detach();
                    }
                    
                    if (obj.parent) {
                        obj.parent.remove(obj);
                    }
                    
                    selectedObject = null;
                    selectionBox.visible = false;
                    updateSceneTree();
                    updateInspector();
                    saveHistory();
                } catch (error) {
                    console.error("Error deleting object:", error);
                }
            }
        }

        function duplicateObject() {
            if (!selectedObject) return;
            
            try {
                const clone = selectedObject.clone();
                
                // Clone materials if mesh
                if (clone.isMesh && selectedObject.material) {
                    clone.material = selectedObject.material.clone();
                }
                
                // Offset position
                clone.position.x += 2;
                clone.position.z += 2;
                clone.name = (selectedObject.name || "Object") + "_COPY";
                
                mainGroup.add(clone);
                selectObject(clone);
                saveHistory();
            } catch (error) {
                console.error("Error duplicating object:", error);
            }
        }

        function setToolMode(mode) {
            if (transformControl && typeof transformControl.setMode === 'function') {
                transformControl.setMode(mode);
            }
            
            document.querySelectorAll('#editor-ui button').forEach(btn => {
                if (btn.id && btn.id.startsWith('tool-')) {
                    btn.classList.remove('active-tool');
                }
            });
            
            const toolBtn = document.getElementById('tool-' + mode);
            if (toolBtn) {
                toolBtn.classList.add('active-tool');
            }
        }

        function toggleSnap() {
            snapEnabled = !snapEnabled;
            
            if (transformControl) {
                if (typeof transformControl.setTranslationSnap === 'function') {
                    transformControl.setTranslationSnap(snapEnabled ? 1 : null);
                }
                if (typeof transformControl.setRotationSnap === 'function') {
                    transformControl.setRotationSnap(snapEnabled ? THREE.MathUtils.degToRad(15) : null);
                }
                if (typeof transformControl.setScaleSnap === 'function') {
                    transformControl.setScaleSnap(snapEnabled ? 0.25 : null);
                }
            }
            
            const btn = document.getElementById('snap-btn');
            if (btn) {
                btn.innerText = snapEnabled ? "SNAP: ON" : "SNAP: OFF";
                btn.classList.toggle('active-tool', snapEnabled);
            }
        }

        function toggleGrid() {
            isGridVisible = !isGridVisible;
            if (gridHelper) {
                gridHelper.visible = isGridVisible;
            }
            const gridBtn = document.getElementById('grid-btn');
            if (gridBtn) {
                gridBtn.innerText = `GRID: ${isGridVisible ? 'ON' : 'OFF'}`;
            }
        }

        function updateWorld() {
            const select = document.getElementById('sky-select');
            if (!select) return;
            
            const color = select.value;
            if (scene && scene.background && scene.fog) {
                scene.background.set(parseInt(color));
                scene.fog.color.set(parseInt(color));
            }
        }

        function exportScene() {
            try {
                const data = {
                    metadata: {
                        version: 6.0,
                        generator: "MSSOG Engine",
                        date: new Date().toISOString()
                    },
                    scene: mainGroup.toJSON()
                };
                
                const json = JSON.stringify(data, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = `MSSOG_Scene_${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            } catch (error) {
                console.error("Error exporting scene:", error);
                alert("Error exporting scene. Please check console.");
            }
        }

        function clearScene() {
            if (confirm("Clear entire scene? This cannot be undone.")) {
                try {
                    // Detach transform control
                    if (transformControl && typeof transformControl.detach === 'function') {
                        transformControl.detach();
                    }
                    
                    // Remove all children except essential helpers
                    const childrenToRemove = [];
                    mainGroup.children.forEach(child => {
                        if (child !== gridHelper && child !== transformControl && child !== selectionBox) {
                            childrenToRemove.push(child);
                        }
                    });
                    
                    childrenToRemove.forEach(child => {
                        mainGroup.remove(child);
                    });
                    
                    // Reset selection
                    selectedObject = null;
                    selectionBox.visible = false;
                    
                    // Create default scene
                    createDefaultScene();
                    
                    updateSceneTree();
                    updateInspector();
                    saveHistory();
                } catch (error) {
                    console.error("Error clearing scene:", error);
                }
            }
        }

        function screenshot() {
            try {
                renderer.render(scene, camera);
                const link = document.createElement('a');
                link.download = `MSSOG_Render_${Date.now()}.png`;
                link.href = renderer.domElement.toDataURL("image/png");
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } catch (error) {
                console.error("Error taking screenshot:", error);
            }
        }

        // --- HISTORY ---
        function saveHistory() {
            try {
                if (historyStep < history.length - 1) {
                    history = history.slice(0, historyStep + 1);
                }
                
                const state = {
                    scene: mainGroup.toJSON(),
                    camera: {
                        position: camera.position.toArray(),
                        rotation: camera.rotation.toArray()
                    }
                };
                
                history.push(JSON.stringify(state));
                
                // Limit history size
                if (history.length > 50) {
                    history.shift();
                }
                
                historyStep = history.length - 1;
            } catch (error) {
                console.error("Error saving history:", error);
            }
        }

        function undo() {
            try {
                if (historyStep > 0) {
                    historyStep--;
                    applyState(history[historyStep]);
                }
            } catch (error) {
                console.error("Error undoing:", error);
            }
        }

        function redo() {
            try {
                if (historyStep < history.length - 1) {
                    historyStep++;
                    applyState(history[historyStep]);
                }
            } catch (error) {
                console.error("Error redoing:", error);
            }
        }

        function applyState(json) {
            try {
                const state = JSON.parse(json);
                const loader = new THREE.ObjectLoader();
                
                // Clear current scene except essential helpers
                const childrenToKeep = [gridHelper, transformControl, selectionBox];
                const childrenToRemove = [];
                
                mainGroup.children.forEach(child => {
                    if (!childrenToKeep.includes(child)) {
                        childrenToRemove.push(child);
                    }
                });
                
                childrenToRemove.forEach(child => {
                    mainGroup.remove(child);
                });
                
                // Load new scene
                loader.parse(state.scene, (obj) => {
                    obj.children.forEach(child => {
                        mainGroup.add(child);
                    });
                    
                    // Restore camera if available
                    if (state.camera) {
                        camera.position.fromArray(state.camera.position);
                        camera.rotation.fromArray(state.camera.rotation);
                        if (orbit && typeof orbit.update === 'function') {
                            orbit.update();
                        }
                    }
                    
                    updateSceneTree();
                    
                    // Try to reselect the object by name
                    if (selectedObject && selectedObject.name) {
                        const objName = selectedObject.name;
                        let found = null;
                        mainGroup.traverse(node => {
                            if (node.name === objName) {
                                found = node;
                            }
                        });
                        if (found) {
                            selectObject(found);
                        } else {
                            selectObject(null);
                        }
                    }
                });
            } catch (error) {
                console.error("Error loading state:", error);
            }
        }

        // --- EVENT HANDLERS ---
        function onSelect(event) {
            // Don't select if clicking on UI elements
            if (event.target.closest('aside') || 
                event.target.closest('.absolute') || 
                event.target.closest('#toolbar') ||
                event.target.tagName.toLowerCase() === 'button' ||
                event.target.tagName.toLowerCase() === 'input' ||
                event.target.tagName.toLowerCase() === 'select') {
                return;
            }
            
            try {
                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                
                // Filter objects that can be selected
                const selectableObjects = [];
                mainGroup.traverse(node => {
                    if (node.isMesh && node.visible && node !== selectionBox) {
                        selectableObjects.push(node);
                    }
                });
                
                const intersects = raycaster.intersectObjects(selectableObjects);
                
                if (intersects.length > 0) {
                    selectObject(intersects[0].object);
                } else {
                    // Deselect if clicking empty space
                    selectObject(null);
                }
            } catch (error) {
                console.error("Error in selection:", error);
            }
        }

        function onKey(event) {
            try {
                // Tool shortcuts
                if (event.key === 'g' || event.key === 'G') {
                    event.preventDefault();
                    setToolMode('translate');
                }
                if (event.key === 'r' || event.key === 'R') {
                    event.preventDefault();
                    setToolMode('rotate');
                }
                if (event.key === 's' || event.key === 'S') {
                    event.preventDefault();
                    setToolMode('scale');
                }
                
                // Delete selected object
                if (event.key === 'Delete' || event.key === 'Backspace') {
                    event.preventDefault();
                    deleteObject();
                }
                
                // Undo/Redo
                if (event.ctrlKey || event.metaKey) {
                    if (event.key === 'z') {
                        event.preventDefault();
                        undo();
                    }
                    if (event.key === 'y' || (event.shiftKey && event.key === 'Z')) {
                        event.preventDefault();
                        redo();
                    }
                    if (event.key === 'd') {
                        event.preventDefault();
                        duplicateObject();
                    }
                    if (event.key === 's') {
                        event.preventDefault();
                        exportScene();
                    }
                }
                
                // Focus on selected object
                if (event.key === 'f' || event.key === 'F') {
                    event.preventDefault();
                    if (selectedObject) {
                        const box = new THREE.Box3().setFromObject(selectedObject);
                        const center = box.getCenter(new THREE.Vector3());
                        const size = box.getSize(new THREE.Vector3());
                        
                        if (orbit && typeof orbit.target === 'object') {
                            orbit.target.copy(center);
                        }
                        
                        const maxDim = Math.max(size.x, size.y, size.z);
                        const fov = camera.fov * (Math.PI / 180);
                        let cameraZ = Math.abs(maxDim / Math.sin(fov / 2));
                        
                        cameraZ *= 1.5; // Add some margin
                        camera.position.copy(center);
                        camera.position.z += cameraZ;
                        
                        if (orbit && typeof orbit.update === 'function') {
                            orbit.update();
                        }
                    }
                }
                
                // Toggle grid
                if (event.key === 'h' || event.key === 'H') {
                    event.preventDefault();
                    toggleGrid();
                }
                
                // Toggle wireframe
                if (event.key === 'w' || event.key === 'W') {
                    event.preventDefault();
                    if (selectedObject && selectedObject.isMesh && selectedObject.material) {
                        editProp('wire', !selectedObject.material.wireframe);
                    }
                }
            } catch (error) {
                console.error("Error handling key event:", error);
            }
        }

        function onResize() {
            try {
                const container = document.getElementById('viewport');
                if (!container) return;
                
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
                
                // Update minimap position
                const minimap = document.getElementById('minimap');
                if (minimap) {
                    minimap.style.right = '20px';
                    minimap.style.bottom = '20px';
                }
            } catch (error) {
                console.error("Error on resize:", error);
            }
        }

        // Initialize when page loads
        window.addEventListener('DOMContentLoaded', () => {
            // Set up password input to submit on Enter
            const passwordInput = document.getElementById('password');
            if (passwordInput) {
                passwordInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        checkAccess();
                    }
                });
            }
        });
    </script>
</body>
</html>
